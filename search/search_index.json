{
    "docs": [
        {
            "location": "/",
            "text": "About\n\n\nForeword\n\n\n\nIn the I.T. world of today, robust and secure applications are becoming more and more important. Many business processes no longer work without I.T. and the dependence of businesses on their I.T. has grown tremendously, meaning we need robust and maintainable applications. An important requirement is to have standards and guidelines, which make it possible to maintain source code created by a number of people quickly and easily. This forms the basis of well functioning off- or on-shoring strategy, as it allows quality assurance to be carried out efficiently at the source. \n\n\nGood standards and guidelines are based on the wealth of experience and knowledge gained from past (and future?) problems, such as those, which can arise in a cloud environment, for example.\n\n\n\nUrban Lankes\n\nPresident of the bord of directors\n\nTrivadis\n\n\n\n\n\nThe Oracle Database Developer community is made stronger by resources freely shared by experts around the world, such as the Trivadis Coding Guidelines. If you have not yet adopted standards for writing SQL and PL/SQL in your applications, this is a great place to start.\n\n\n\n\nSteven Feuerstein\n\nTeam Lead, Oracle Developer Advocates\n\nOracle\n\n\n\n\nCoding Guidelines are a crucial part of software development. It is a matter of fact, that code is more often read than written \u2013 therefore we should take efforts to ease the work of the reader, which is not necessarily the author.\n\n\nI am convinced that this standard may be a good starting point for your own guidelines.\n\n\nRoger Troller\n\nSenior Consultant\n\nfinnova AG Bankware\n\n\n\n\nLicense\n\n\nThe Trivadis PL/SQL & SQL Coding Guidelines are licensed under the Apache License, Version 2.0. You may obtain a copy of the License at \nhttp://www.apache.org/licenses/LICENSE-2.0\n.\n\n\nTrademarks\n\n\nAll terms that are known trademarks or service marks have been capitalized. All trademarks are the property of their respective owners.\n\n\nDisclaimer\n\n\nThe authors and publisher shall have neither liability nor responsibility to any person or entity with respect to the loss or damages arising from the information contained in this work. This work may include inaccuracies or typographical errors and solely represent the opinions of the authors. Changes are periodically made to this document without notice. The authors reserve the right to revise this document at any time without notice.\n\n\nRevision History\n\n\n\n\n\n\n\n\nVersion\n\n\nWho\n\n\nDate\n\n\nComment\n\n\n\n\n\n\n\n\n\n\n0.1\n\n\nTroller\n\n\n17.03.2009\n\n\nCreated.\n\n\n\n\n\n\n0.1\n\n\nTroller\n\n\n17.03.2009\n\n\nCreated.\n\n\n\n\n\n\n0.2\n\n\nKulessa\n\n\n04.05.2009\n\n\nExtended.\n\n\n\n\n\n\n0.3\n\n\nReiner\n\n\n12.05.2009\n\n\nExtended with comments in code.\n\n\n\n\n\n\n0.4\n\n\nTroller\n\n\n14.05.2009\n\n\nExtended formatting.\n\n\n\n\n\n\n0.5\n\n\nKulessa\n\n\n20.05.2009\n\n\nAdded more CodeXpert rules.\n\n\n\n\n\n\n0.6\n\n\nTroller\n\n\n22.05.2009\n\n\nFormatting changes. Added categories to rules.\n\n\n\n\n\n\n0.7\n\n\nReiner\n\n\n10.06.2009\n\n\nExtended with example code commenting.\n\n\n\n\n\n\n0.8\n\n\nTroller\n\n\n18.06.2009\n\n\nFinalized.\n\n\n\n\n\n\n0.9\n\n\nBushnell\n\n\n23.06.2009\n\n\nTranslation.\n\n\n\n\n\n\n1.0\n\n\nTroller\n\n\n01.07.2009\n\n\nReady for inspection.\n\n\n\n\n\n\n1.1\n\n\nTroller\n\n\n19.08.2009\n\n\nAdded Inspection results AFl.\n\n\n\n\n\n\n1.2\n\n\nTroller\n\n\n21.08.2009\n\n\nAdded Inspection results ThM.\n\n\n\n\n\n\n1.3\n\n\nTroller\n\n\nApril 2010\n\n\nSeveral Corrections. New Rule Oracle Supplied Packages.\n\n\n\n\n\n\n1.3.1\n\n\nTroller\n\n\nOctober 2010\n\n\nSome formatting.\n\n\n\n\n\n\n2.0\n\n\nTroller\n\n\nAugust 2011\n\n\nAdded Error Handling Section. Added rule 23, 30, 31, 43.\n\n\n\n\n\n\n3.0\n\n\nTroller\n\n\nJanuary 2016\n\n\nAdded Rules for ORACLE 12c. Added SQALE Metrics. New guideline numbering system.\n\n\n\n\n\n\n3.1\n\n\nTroller\n\n\nApril 2016\n\n\nCorrections\n\n\n\n\n\n\n3.2\n\n\nSalvisberg\n\n\nJanuary 2017\n\n\nVarious small corrections\n\n\n\n\n\n\n3.3\n\n\nSalvisberg\n\n\n07.07.2018\n\n\nMigrated from Microsoft Word document to \nMkDocs\n, added missing reasons, prefixed rules with \"G-\" as in PL/SQL Cop.\n\n\n\n\n\n\n3.4\n\n\n\n\n\n\nwork in progress",
            "title": "About"
        },
        {
            "location": "/#about",
            "text": "",
            "title": "About"
        },
        {
            "location": "/#foreword",
            "text": "In the I.T. world of today, robust and secure applications are becoming more and more important. Many business processes no longer work without I.T. and the dependence of businesses on their I.T. has grown tremendously, meaning we need robust and maintainable applications. An important requirement is to have standards and guidelines, which make it possible to maintain source code created by a number of people quickly and easily. This forms the basis of well functioning off- or on-shoring strategy, as it allows quality assurance to be carried out efficiently at the source.   Good standards and guidelines are based on the wealth of experience and knowledge gained from past (and future?) problems, such as those, which can arise in a cloud environment, for example.  \nUrban Lankes \nPresident of the bord of directors \nTrivadis   \nThe Oracle Database Developer community is made stronger by resources freely shared by experts around the world, such as the Trivadis Coding Guidelines. If you have not yet adopted standards for writing SQL and PL/SQL in your applications, this is a great place to start.   Steven Feuerstein \nTeam Lead, Oracle Developer Advocates \nOracle   Coding Guidelines are a crucial part of software development. It is a matter of fact, that code is more often read than written \u2013 therefore we should take efforts to ease the work of the reader, which is not necessarily the author.  I am convinced that this standard may be a good starting point for your own guidelines.  Roger Troller \nSenior Consultant \nfinnova AG Bankware",
            "title": "Foreword"
        },
        {
            "location": "/#license",
            "text": "The Trivadis PL/SQL & SQL Coding Guidelines are licensed under the Apache License, Version 2.0. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 .",
            "title": "License"
        },
        {
            "location": "/#trademarks",
            "text": "All terms that are known trademarks or service marks have been capitalized. All trademarks are the property of their respective owners.",
            "title": "Trademarks"
        },
        {
            "location": "/#disclaimer",
            "text": "The authors and publisher shall have neither liability nor responsibility to any person or entity with respect to the loss or damages arising from the information contained in this work. This work may include inaccuracies or typographical errors and solely represent the opinions of the authors. Changes are periodically made to this document without notice. The authors reserve the right to revise this document at any time without notice.",
            "title": "Disclaimer"
        },
        {
            "location": "/#revision-history",
            "text": "Version  Who  Date  Comment      0.1  Troller  17.03.2009  Created.    0.1  Troller  17.03.2009  Created.    0.2  Kulessa  04.05.2009  Extended.    0.3  Reiner  12.05.2009  Extended with comments in code.    0.4  Troller  14.05.2009  Extended formatting.    0.5  Kulessa  20.05.2009  Added more CodeXpert rules.    0.6  Troller  22.05.2009  Formatting changes. Added categories to rules.    0.7  Reiner  10.06.2009  Extended with example code commenting.    0.8  Troller  18.06.2009  Finalized.    0.9  Bushnell  23.06.2009  Translation.    1.0  Troller  01.07.2009  Ready for inspection.    1.1  Troller  19.08.2009  Added Inspection results AFl.    1.2  Troller  21.08.2009  Added Inspection results ThM.    1.3  Troller  April 2010  Several Corrections. New Rule Oracle Supplied Packages.    1.3.1  Troller  October 2010  Some formatting.    2.0  Troller  August 2011  Added Error Handling Section. Added rule 23, 30, 31, 43.    3.0  Troller  January 2016  Added Rules for ORACLE 12c. Added SQALE Metrics. New guideline numbering system.    3.1  Troller  April 2016  Corrections    3.2  Salvisberg  January 2017  Various small corrections    3.3  Salvisberg  07.07.2018  Migrated from Microsoft Word document to  MkDocs , added missing reasons, prefixed rules with \"G-\" as in PL/SQL Cop.    3.4    work in progress",
            "title": "Revision History"
        },
        {
            "location": "/1-introduction/introduction/",
            "text": "Introduction\n\n\nThis document describes rules and recommendations for developing applications using the PL/SQL & SQL Language. \n\n\nScope\n\n\nThis document applies to the PL/SQL and SQL language as used within ORACLE databases and tools, which access ORACLE databases.\n\n\nDocument Conventions\n\n\nSQALE (Software Quality Assessment based on Lifecycle Expectations) is a method to support the evaluation of a software application source code. It is a generic method, independent of the language and source code analysis tools.\n\n\nSQALE characteristics and subcharacteristics\n\n\n\n\n\n\n\n\nCharacteristic\n\n\nDescription and Subcharacteristics\n\n\n\n\n\n\n\n\n\n\nChangeability\n\n\nThe capability of the software product to enable a specified modification to be implemented.\nArchitecture related changeability\nLogic related changeability\nData related changeability\n\n\n\n\n\n\nEfficiency\n\n\nThe capability of the software product to provide appropriate performance, relative to the amount of resources used, under stated conditions.\nMemory use\nProcessor use\nNetwork use\n\n\n\n\n\n\nMaintainability\n\n\nThe capability of the software product to be modified. Modifications may include corrections, improvements or adaptation of the software to changes in environment, and in requirements and functional specifications.\nUnderstandability\nReadability\n\n\n\n\n\n\nPortability\n\n\nThe capability of the software product to be transferred from one environment to another.\nCompiler related portability\nHardware related portability\nLanguage related portability\nOS related portability\nSoftware related portability\nTime zone related portability.\n\n\n\n\n\n\nReliability\n\n\nThe capability of the software product to maintain a specified level of performance when used under specified conditions.\nArchitecture related reliability\nData related reliability\nException handling\nFault tolerance\nInstruction related reliability\nLogic related reliability\nResource related reliability\nSynchronization related reliability\nUnit tests coverage.\n\n\n\n\n\n\nReusability\n\n\nThe capability of the software product to be reused within the development process.\nModularity\nTransportability.\n\n\n\n\n\n\nSecurity\n\n\nThe capability of the software product to protect information and data so that unauthorized persons or systems cannot read or modify them and authorized persons or systems are not denied access to them.\nAPI abuse\nErrors (e.g. leaving a system in a vulnerable state)\nInput validatation and representation\nSecurity features.\n\n\n\n\n\n\nTestability\n\n\nThe capability of the software product to enable modified software to be validated.\nIntegration level testability\nUnit level testability.\n\n\n\n\n\n\n\n\nSeverity of the rule\n\n\n\n\nBlocker\n\n\nWill or may result in a bug.\n\n\n\n\n\n\nCritical\n\n\nWill have a high/direct impact on the maintenance cost.\n\n\n\n\n\n\nMajor\n\n\nWill have a medium/potential impact on the maintenance cost.\n\n\n\n\n\n\nMinor\n\n\nWill have a low impact on the maintenance cost.\n\n\n\n\n\n\nInfo\n\n\nVery low impact; it is just a remediation cost report.\n\n\n\n\nKeywords used\n\n\n\n\n\n\n\n\nKeyword\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nAlways\n\n\nEmphasizes this rule must be enforced.\n\n\n\n\n\n\nNever\n\n\nEmphasizes this action must not happen.\n\n\n\n\n\n\nAvoid\n\n\nEmphasizes that the action should be prevented, but some exceptions may exist.\n\n\n\n\n\n\nTry\n\n\nEmphasizes that the rule should be attempted whenever possible and appropriate.\n\n\n\n\n\n\nExample\n\n\nPrecedes text used to illustrate a rule or a recommendation.\n\n\n\n\n\n\nReason\n\n\nExplains the thoughts and purpose behind a rule or a recommendation.\n\n\n\n\n\n\nRestriction\n\n\nDescribes the circumstances to be fulfilled to make use of a rule.\n\n\n\n\n\n\n\n\nWhy are standards important\n\n\nFor a machine executing a program, code formatting is of no importance. However, for the human eye, well-formatted code is much easier to read. Modern tools can help to implement format and coding rules.\n\n\nImplementing formatting and coding standards has the following advantages for PL/SQL development:\n\n\n\n\nWell-formatted code is easier to read, analyze and maintain (not only for the author but also for other developers).\n\n\nThe developers do not have to define their own guidelines - it is already defined.\n\n\nThe code has a structure that makes it easier to avoid making errors.\n\n\nThe code is more efficient concerning performance and organization of the whole application.\n\n\nThe code is more modular and thus easier to use for other applications.\n\n\n\n\nThis document only defines possible standards. These standards are not written in stone, but are meant as guidelines. If standards already exist, and they are different from those in this document, it makes no sense to change them.",
            "title": "Introduction"
        },
        {
            "location": "/1-introduction/introduction/#introduction",
            "text": "This document describes rules and recommendations for developing applications using the PL/SQL & SQL Language.",
            "title": "Introduction"
        },
        {
            "location": "/1-introduction/introduction/#scope",
            "text": "This document applies to the PL/SQL and SQL language as used within ORACLE databases and tools, which access ORACLE databases.",
            "title": "Scope"
        },
        {
            "location": "/1-introduction/introduction/#document-conventions",
            "text": "SQALE (Software Quality Assessment based on Lifecycle Expectations) is a method to support the evaluation of a software application source code. It is a generic method, independent of the language and source code analysis tools.",
            "title": "Document Conventions"
        },
        {
            "location": "/1-introduction/introduction/#sqale-characteristics-and-subcharacteristics",
            "text": "Characteristic  Description and Subcharacteristics      Changeability  The capability of the software product to enable a specified modification to be implemented. Architecture related changeability Logic related changeability Data related changeability    Efficiency  The capability of the software product to provide appropriate performance, relative to the amount of resources used, under stated conditions. Memory use Processor use Network use    Maintainability  The capability of the software product to be modified. Modifications may include corrections, improvements or adaptation of the software to changes in environment, and in requirements and functional specifications. Understandability Readability    Portability  The capability of the software product to be transferred from one environment to another. Compiler related portability Hardware related portability Language related portability OS related portability Software related portability Time zone related portability.    Reliability  The capability of the software product to maintain a specified level of performance when used under specified conditions. Architecture related reliability Data related reliability Exception handling Fault tolerance Instruction related reliability Logic related reliability Resource related reliability Synchronization related reliability Unit tests coverage.    Reusability  The capability of the software product to be reused within the development process. Modularity Transportability.    Security  The capability of the software product to protect information and data so that unauthorized persons or systems cannot read or modify them and authorized persons or systems are not denied access to them. API abuse Errors (e.g. leaving a system in a vulnerable state) Input validatation and representation Security features.    Testability  The capability of the software product to enable modified software to be validated. Integration level testability Unit level testability.",
            "title": "SQALE characteristics and subcharacteristics"
        },
        {
            "location": "/1-introduction/introduction/#severity-of-the-rule",
            "text": "Blocker  Will or may result in a bug.    Critical  Will have a high/direct impact on the maintenance cost.    Major  Will have a medium/potential impact on the maintenance cost.    Minor  Will have a low impact on the maintenance cost.    Info  Very low impact; it is just a remediation cost report.",
            "title": "Severity of the rule"
        },
        {
            "location": "/1-introduction/introduction/#keywords-used",
            "text": "Keyword  Meaning      Always  Emphasizes this rule must be enforced.    Never  Emphasizes this action must not happen.    Avoid  Emphasizes that the action should be prevented, but some exceptions may exist.    Try  Emphasizes that the rule should be attempted whenever possible and appropriate.    Example  Precedes text used to illustrate a rule or a recommendation.    Reason  Explains the thoughts and purpose behind a rule or a recommendation.    Restriction  Describes the circumstances to be fulfilled to make use of a rule.",
            "title": "Keywords used"
        },
        {
            "location": "/1-introduction/introduction/#why-are-standards-important",
            "text": "For a machine executing a program, code formatting is of no importance. However, for the human eye, well-formatted code is much easier to read. Modern tools can help to implement format and coding rules.  Implementing formatting and coding standards has the following advantages for PL/SQL development:   Well-formatted code is easier to read, analyze and maintain (not only for the author but also for other developers).  The developers do not have to define their own guidelines - it is already defined.  The code has a structure that makes it easier to avoid making errors.  The code is more efficient concerning performance and organization of the whole application.  The code is more modular and thus easier to use for other applications.   This document only defines possible standards. These standards are not written in stone, but are meant as guidelines. If standards already exist, and they are different from those in this document, it makes no sense to change them.",
            "title": "Why are standards important"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/",
            "text": "Naming Conventions\n\n\nGeneral Guidelines\n\n\n\n\nNever use names with a leading numeric character.\n\n\nAlways choose meaningful and specific names.\n\n\nAvoid using abbreviations unless the full name is excessively long.\n\n\nAvoid long abbreviations. Abbreviations should be shorter than 5 characters.\n\n\nAny abbreviations must be widely known and accepted. \n\n\nCreate a glossary with all accepted abbreviations.\n\n\nNever use ORACLE keywords as names. A list of ORACLEs keywords may be found in the dictionary view \nV$RESERVED_WORDS\n.\n\n\nAvoid adding redundant or meaningless prefixes and suffixes to identifiers.\nExample: \nCREATE TABLE emp_table\n.\n\n\nAlways use one spoken language (e.g. English, German, French) for all objects in your application.\n\n\nAlways use the same names for elements with the same meaning.\n\n\n\n\nNaming Conventions for PL/SQL\n\n\nIn general, ORACLE is not case sensitive with names. A variable named personname is equal to one named PersonName, as well as to one named PERSONNAME. Some products (e.g. TMDA by Trivadis, APEX, OWB) put each name within double quotes (\") so ORACLE will treat these names to be case sensitive. Using case sensitive variable names force developers to use double quotes for each reference to the variable. Our recommendation is to write all names in lowercase and to avoid double quoted identifiers.\n\n\nA widely used convention is to follow a \n{prefix}variablecontent{suffix}\n pattern.\n\n\nThe following table shows a possible set of naming conventions. \n\n\n\n\n\n\n\n\nIdentifier\n\n\nPrefix\n\n\nSuffix\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nGlobal Variable\n\n\ng_\n\n\n\n\ng_version\n\n\n\n\n\n\nLocal Variable\n\n\nl_\n\n\n\n\nl_version\n\n\n\n\n\n\nCursor\n\n\nc_\n\n\n\n\nc_employees\n\n\n\n\n\n\nRecord\n\n\nr_\n\n\n\n\nr_employee\n\n\n\n\n\n\nArray / Table\n\n\nt_\n\n\n\n\nt_employees\n\n\n\n\n\n\nObject\n\n\no_\n\n\n\n\no_employee\n\n\n\n\n\n\nCursor Parameter\n\n\np_\n\n\n\n\np_empno\n\n\n\n\n\n\nIn Parameter\n\n\nin_\n\n\n\n\nin_empno\n\n\n\n\n\n\nOut Parameter\n\n\nout_\n\n\n\n\nout_ename\n\n\n\n\n\n\nIn/Out Parameter\n\n\nio_\n\n\n\n\nio_employee\n\n\n\n\n\n\nRecord Type Definitions\n\n\nr_\n\n\n_type\n\n\nr_employee_type\n\n\n\n\n\n\nArray/Table Type Definitions\n\n\nt_\n\n\n_type\n\n\nt_employees_type\n\n\n\n\n\n\nException\n\n\ne_\n\n\n\n\ne_employee_exists\n\n\n\n\n\n\nConstants\n\n\nco_\n\n\n\n\nco_empno\n\n\n\n\n\n\nSubtypes\n\n\n\n\n_type\n\n\nbig_string_type\n\n\n\n\n\n\n\n\nDatabase Object Naming Conventions\n\n\nNever enclose object names (table names, column names, etc.) in double quotes to enforce mixed case or lower case object names in the data dictionary.\n\n\nCollection Type\n\n\nA collection type should include the name of the collected objects in their name. Furthermore, they should have the suffix \n_ct\n to identify it as a collection.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\nemployees_ct\n\n\norders_ct\n\n\n\n\nColumn\n\n\nSingular name of what is stored in the column (unless the column data type is a collection, in this case you use plural names)\n\n\nAdd a comment to the database dictionary for every column.\n\n\nDML / Instead of Trigger\n\n\nChoose a naming convention that includes:\n\n\neither\n\n\n\n\nthe name of the object the trigger is added to,\n\n\nany of the triggering events:\n\n\n_br_iud\n for Before Row on Insert, Update and Delete\n\n\n_io_id\n for Instead of Insert and Delete\n\n\n\n\n\n\n\n\nor\n\n\n\n\nthe name of the object the trigger is added to,\n\n\nthe activity done by the trigger,\n\n\nthe suffix \n_trg\n\n\n\n\nExamples:\n\n\n\n\nemployees_br_iud\n\n\norders_audit_trg\n\n\norders_journal_trg\n\n\n\n\nForeign Key Constraint\n\n\nTable abbreviation followed by referenced table abbreviation followed by a \n_fk\n and an optional number suffix.\n\n\nExamples:\n\n\n\n\nempl_dept_fk\n\n\nsct_icmd_ic_fk1\n\n\n\n\nFunction\n\n\nName is built from a verb followed by a noun in general. Nevertheless, it is not sensible to call a function \nget_...\n as a function always gets something.\n\n\nThe name of the function should answer the question \u201cWhat is the outcome of the function?\u201d\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExample: \nemployee_by_id\n\n\nIf more than one function provides the same outcome, you have to be more specific with the name.\n\n\nIndex\n\n\nIndexes serving a constraint (primary, unique or foreign key) are named accordingly. \n\n\nOther indexes should have the name of the table and columns (or their purpose) in their name and should also have \n_idx\n as a suffix.\n\n\nObject Type\n\n\nThe name of an object type is built by its content (singular) followed by a \n_ot\n suffix.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExample: \nemployee_ot\n\n\nPackage\n\n\nName is built from the content that is contained within the package.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\nemployees_api\n - API for the employee table\n\n\nlogging_up\n - Utilities including logging support\n\n\n\n\nPrimary Key Constraint\n\n\nTable name or table abbreviation followed by the suffix \n_pk\n.\n\n\nExamples:\n\n\n\n\nemployees_pk\n\n\ndepartments_pk\n\n\nsct_contracts_pk\n\n\n\n\nProcedure\n\n\nName is built from a verb followed by a noun. The name of the procedure should answer the question \u201cWhat is done?\u201d \n\n\nProcedures and functions are often named with underscores between words because some editors write all letters in uppercase in the object tree, so it is difficult to read them.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\ncalculate_salary\n\n\nset_hiredate\n\n\ncheck_order_state\n\n\n\n\nSequence\n\n\nName is built from the table name (or its abbreviation) the sequence serves as primary key generator and the suffix \n_seq\n or the purpose of the sequence followed by a \n_seq\n.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\nemployees_seq\n\n\norder_number_seq\n\n\n\n\nSynonym\n\n\nSynonyms should be used to address an object in a foreign schema rather than to rename an object. Therefore, synonyms should share the name with the referenced object.\n\n\nSystem Trigger\n\n\nName of the event the trigger is based on.\n\n\n\n\nActivity done by the trigger\n\n\nSuffix \n_trg\n\n\n\n\nExamples:\n\n\n\n\nddl_audit_trg\n\n\nlogon_trg\n\n\n\n\nTable\n\n\nPlural name of what is contained in the table (unless the table is designed to always hold one row only \u2013 then you should use a singular name)\n\n\nAdd a comment to the database dictionary for every table and every column in the table.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\nemployees\n\n\ndepartments\n\n\nsct_contracts\n\n\nsct_contract_lines\n\n\nsct_incentive_modules\n\n\n\n\nTemporary Table (Global Temporary Table)\n\n\nNaming as described for tables.\n\n\nOptionally suffixed by \n_tmp\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\nemployees_tmp\n\n\ncontracts_tmp\n\n\n\n\nUnique Key Constraint\n\n\nTable name or table abbreviation followed by the role of the unique key constraint, a \n_uk\n and an optional number suffix.\n\n\nExamples:\n\n\n\n\nemployees_name_uk\n\n\ndepartments_deptno_uk\n\n\nsct_contracts_uk\n\n\nsct_coli_uk\n\n\nsct_icmd_uk1\n\n\n\n\nView\n\n\nPlural name of what is contained in the view.\nOptionally suffixed by an indicator identifying the object as a view (mostly used, when a 1:1 view layer lies above the table layer)\n\n\nAdd a comment to the database dictionary for every view and every column.\n\n\nOptionally prefixed by a project abbreviation.\n\n\nExamples:\n\n\n\n\nactive_orders\n\n\norders_v\n - a view to the orders table",
            "title": "Naming Conventions"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#naming-conventions",
            "text": "",
            "title": "Naming Conventions"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#general-guidelines",
            "text": "Never use names with a leading numeric character.  Always choose meaningful and specific names.  Avoid using abbreviations unless the full name is excessively long.  Avoid long abbreviations. Abbreviations should be shorter than 5 characters.  Any abbreviations must be widely known and accepted.   Create a glossary with all accepted abbreviations.  Never use ORACLE keywords as names. A list of ORACLEs keywords may be found in the dictionary view  V$RESERVED_WORDS .  Avoid adding redundant or meaningless prefixes and suffixes to identifiers. Example:  CREATE TABLE emp_table .  Always use one spoken language (e.g. English, German, French) for all objects in your application.  Always use the same names for elements with the same meaning.",
            "title": "General Guidelines"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql",
            "text": "In general, ORACLE is not case sensitive with names. A variable named personname is equal to one named PersonName, as well as to one named PERSONNAME. Some products (e.g. TMDA by Trivadis, APEX, OWB) put each name within double quotes (\") so ORACLE will treat these names to be case sensitive. Using case sensitive variable names force developers to use double quotes for each reference to the variable. Our recommendation is to write all names in lowercase and to avoid double quoted identifiers.  A widely used convention is to follow a  {prefix}variablecontent{suffix}  pattern.  The following table shows a possible set of naming conventions.      Identifier  Prefix  Suffix  Example      Global Variable  g_   g_version    Local Variable  l_   l_version    Cursor  c_   c_employees    Record  r_   r_employee    Array / Table  t_   t_employees    Object  o_   o_employee    Cursor Parameter  p_   p_empno    In Parameter  in_   in_empno    Out Parameter  out_   out_ename    In/Out Parameter  io_   io_employee    Record Type Definitions  r_  _type  r_employee_type    Array/Table Type Definitions  t_  _type  t_employees_type    Exception  e_   e_employee_exists    Constants  co_   co_empno    Subtypes   _type  big_string_type",
            "title": "Naming Conventions for PL/SQL"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#database-object-naming-conventions",
            "text": "Never enclose object names (table names, column names, etc.) in double quotes to enforce mixed case or lower case object names in the data dictionary.",
            "title": "Database Object Naming Conventions"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#collection-type",
            "text": "A collection type should include the name of the collected objects in their name. Furthermore, they should have the suffix  _ct  to identify it as a collection.  Optionally prefixed by a project abbreviation.  Examples:   employees_ct  orders_ct",
            "title": "Collection Type"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#column",
            "text": "Singular name of what is stored in the column (unless the column data type is a collection, in this case you use plural names)  Add a comment to the database dictionary for every column.",
            "title": "Column"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#dml-instead-of-trigger",
            "text": "Choose a naming convention that includes:  either   the name of the object the trigger is added to,  any of the triggering events:  _br_iud  for Before Row on Insert, Update and Delete  _io_id  for Instead of Insert and Delete     or   the name of the object the trigger is added to,  the activity done by the trigger,  the suffix  _trg   Examples:   employees_br_iud  orders_audit_trg  orders_journal_trg",
            "title": "DML / Instead of Trigger"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#foreign-key-constraint",
            "text": "Table abbreviation followed by referenced table abbreviation followed by a  _fk  and an optional number suffix.  Examples:   empl_dept_fk  sct_icmd_ic_fk1",
            "title": "Foreign Key Constraint"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#function",
            "text": "Name is built from a verb followed by a noun in general. Nevertheless, it is not sensible to call a function  get_...  as a function always gets something.  The name of the function should answer the question \u201cWhat is the outcome of the function?\u201d  Optionally prefixed by a project abbreviation.  Example:  employee_by_id  If more than one function provides the same outcome, you have to be more specific with the name.",
            "title": "Function"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#index",
            "text": "Indexes serving a constraint (primary, unique or foreign key) are named accordingly.   Other indexes should have the name of the table and columns (or their purpose) in their name and should also have  _idx  as a suffix.",
            "title": "Index"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#object-type",
            "text": "The name of an object type is built by its content (singular) followed by a  _ot  suffix.  Optionally prefixed by a project abbreviation.  Example:  employee_ot",
            "title": "Object Type"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#package",
            "text": "Name is built from the content that is contained within the package.  Optionally prefixed by a project abbreviation.  Examples:   employees_api  - API for the employee table  logging_up  - Utilities including logging support",
            "title": "Package"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#primary-key-constraint",
            "text": "Table name or table abbreviation followed by the suffix  _pk .  Examples:   employees_pk  departments_pk  sct_contracts_pk",
            "title": "Primary Key Constraint"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#procedure",
            "text": "Name is built from a verb followed by a noun. The name of the procedure should answer the question \u201cWhat is done?\u201d   Procedures and functions are often named with underscores between words because some editors write all letters in uppercase in the object tree, so it is difficult to read them.  Optionally prefixed by a project abbreviation.  Examples:   calculate_salary  set_hiredate  check_order_state",
            "title": "Procedure"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#sequence",
            "text": "Name is built from the table name (or its abbreviation) the sequence serves as primary key generator and the suffix  _seq  or the purpose of the sequence followed by a  _seq .  Optionally prefixed by a project abbreviation.  Examples:   employees_seq  order_number_seq",
            "title": "Sequence"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#synonym",
            "text": "Synonyms should be used to address an object in a foreign schema rather than to rename an object. Therefore, synonyms should share the name with the referenced object.",
            "title": "Synonym"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#system-trigger",
            "text": "Name of the event the trigger is based on.   Activity done by the trigger  Suffix  _trg   Examples:   ddl_audit_trg  logon_trg",
            "title": "System Trigger"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#table",
            "text": "Plural name of what is contained in the table (unless the table is designed to always hold one row only \u2013 then you should use a singular name)  Add a comment to the database dictionary for every table and every column in the table.  Optionally prefixed by a project abbreviation.  Examples:   employees  departments  sct_contracts  sct_contract_lines  sct_incentive_modules",
            "title": "Table"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#temporary-table-global-temporary-table",
            "text": "Naming as described for tables.  Optionally suffixed by  _tmp  Optionally prefixed by a project abbreviation.  Examples:   employees_tmp  contracts_tmp",
            "title": "Temporary Table (Global Temporary Table)"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#unique-key-constraint",
            "text": "Table name or table abbreviation followed by the role of the unique key constraint, a  _uk  and an optional number suffix.  Examples:   employees_name_uk  departments_deptno_uk  sct_contracts_uk  sct_coli_uk  sct_icmd_uk1",
            "title": "Unique Key Constraint"
        },
        {
            "location": "/2-naming-conventions/naming-conventions/#view",
            "text": "Plural name of what is contained in the view.\nOptionally suffixed by an indicator identifying the object as a view (mostly used, when a 1:1 view layer lies above the table layer)  Add a comment to the database dictionary for every view and every column.  Optionally prefixed by a project abbreviation.  Examples:   active_orders  orders_v  - a view to the orders table",
            "title": "View"
        },
        {
            "location": "/3-coding-style/coding-style/",
            "text": "Coding Style\n\n\nFormatting\n\n\nRules\n\n\n\n\n\n\n\n\nRule\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nKeywords are written uppercase, names are written in lowercase.\n\n\n\n\n\n\n2\n\n\n3 space indention.\n\n\n\n\n\n\n3\n\n\nOne command per line.\n\n\n\n\n\n\n4\n\n\nKeywords \nLOOP\n, \nELSE\n, \nELSIF\n, \nEND IF\n, \nWHEN\n on a new line.\n\n\n\n\n\n\n5\n\n\nCommas in front of separated elements.\n\n\n\n\n\n\n6\n\n\nCall parameters aligned, operators aligned, values aligned.\n\n\n\n\n\n\n7\n\n\nSQL keywords are right aligned within a SQL command.\n\n\n\n\n\n\n8\n\n\nWithin a program unit only line comments \n--\n are used.\n\n\n\n\n\n\n9\n\n\nBrackets are used when needed or when helpful to clarify a construct.\n\n\n\n\n\n\n\n\nExample\n\n\nPROCEDURE set_salary(in_employee_id IN employees.employee_id%TYPE) IS\n   CURSOR c_employees(p_employee_id IN employees.employee_id%TYPE) IS \n      SELECT last_name\n            ,first_name\n            ,salary\n        FROM employees\n       WHERE employee_id = p_employee_id\n       ORDER BY last_name\n               ,first_name;\n\n   r_employee     c_employees%ROWTYPE;\n   l_new_salary   employees.salary%TYPE;\nBEGIN\n   OPEN  c_employees(p_employee_id => in_employee_id);\n   FETCH c_employees INTO r_employee;\n   CLOSE c_employees;\n\n   new_salary (in_employee_id => in_employee_id\n              ,out_salary     => l_new_salary);\n\n   -- Check whether salary has changed\n   IF r_employee.salary <> l_new_salary THEN\n      UPDATE employees\n         SET salary = l_new_salary\n       WHERE employee_id = in_employee_id;\n   END IF;\nEND set_salary;\n\n\n\n\nCode Commenting\n\n\nConventions\n\n\nInside a program unit only use the line commenting technique \n--\n unless you temporarly deactivate code sections for testing.\n\n\nTo comment the source code for later document generation, comments like \n/** ... */\n are used. Within these documentation comments, tags may be used to define the documentation structure.\n\n\nTools like ORACLE SQL Developer or PL/SQL Developer include documentation functionality based on a javadoc-like tagging. \n\n\nCommenting Tags\n\n\n\n\n\n\n\n\nTag\n\n\nMeaning\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nparam\n\n\nDescription of a parameter.\n\n\n@param in_string input string\n\n\n\n\n\n\nreturn\n\n\nDescription of the return value of a function.\n\n\n@return result of the calculation\n\n\n\n\n\n\nthrows\n\n\nDescribe errors that may be raised by the program unit.\n\n\n@throws NO_DATA_FOUND\n\n\n\n\n\n\n\n\nExample\n\n\nThis is an example using the documentation capabilities of SQL Developer. \n\n\n/**\nCheck whether we passed a valid sql name\n\n@param   in_name  string to be checked\n@return  in_name if the string represents a valid sql name\n@throws  ORA-44003: invalid SQL name \n\n<b>Call Example:</b>\n<pre>\n   SELECT TVDAssert.valid_sql_name('TEST') from dual;\n   SELECT TVDAssert.valid_sql_name('123') from dual\n</pre>\n*/",
            "title": "Coding Style"
        },
        {
            "location": "/3-coding-style/coding-style/#coding-style",
            "text": "",
            "title": "Coding Style"
        },
        {
            "location": "/3-coding-style/coding-style/#formatting",
            "text": "",
            "title": "Formatting"
        },
        {
            "location": "/3-coding-style/coding-style/#rules",
            "text": "Rule  Description      1  Keywords are written uppercase, names are written in lowercase.    2  3 space indention.    3  One command per line.    4  Keywords  LOOP ,  ELSE ,  ELSIF ,  END IF ,  WHEN  on a new line.    5  Commas in front of separated elements.    6  Call parameters aligned, operators aligned, values aligned.    7  SQL keywords are right aligned within a SQL command.    8  Within a program unit only line comments  --  are used.    9  Brackets are used when needed or when helpful to clarify a construct.",
            "title": "Rules"
        },
        {
            "location": "/3-coding-style/coding-style/#example",
            "text": "PROCEDURE set_salary(in_employee_id IN employees.employee_id%TYPE) IS\n   CURSOR c_employees(p_employee_id IN employees.employee_id%TYPE) IS \n      SELECT last_name\n            ,first_name\n            ,salary\n        FROM employees\n       WHERE employee_id = p_employee_id\n       ORDER BY last_name\n               ,first_name;\n\n   r_employee     c_employees%ROWTYPE;\n   l_new_salary   employees.salary%TYPE;\nBEGIN\n   OPEN  c_employees(p_employee_id => in_employee_id);\n   FETCH c_employees INTO r_employee;\n   CLOSE c_employees;\n\n   new_salary (in_employee_id => in_employee_id\n              ,out_salary     => l_new_salary);\n\n   -- Check whether salary has changed\n   IF r_employee.salary <> l_new_salary THEN\n      UPDATE employees\n         SET salary = l_new_salary\n       WHERE employee_id = in_employee_id;\n   END IF;\nEND set_salary;",
            "title": "Example"
        },
        {
            "location": "/3-coding-style/coding-style/#code-commenting",
            "text": "",
            "title": "Code Commenting"
        },
        {
            "location": "/3-coding-style/coding-style/#conventions",
            "text": "Inside a program unit only use the line commenting technique  --  unless you temporarly deactivate code sections for testing.  To comment the source code for later document generation, comments like  /** ... */  are used. Within these documentation comments, tags may be used to define the documentation structure.  Tools like ORACLE SQL Developer or PL/SQL Developer include documentation functionality based on a javadoc-like tagging.",
            "title": "Conventions"
        },
        {
            "location": "/3-coding-style/coding-style/#commenting-tags",
            "text": "Tag  Meaning  Example      param  Description of a parameter.  @param in_string input string    return  Description of the return value of a function.  @return result of the calculation    throws  Describe errors that may be raised by the program unit.  @throws NO_DATA_FOUND",
            "title": "Commenting Tags"
        },
        {
            "location": "/3-coding-style/coding-style/#example_1",
            "text": "This is an example using the documentation capabilities of SQL Developer.   /**\nCheck whether we passed a valid sql name\n\n@param   in_name  string to be checked\n@return  in_name if the string represents a valid sql name\n@throws  ORA-44003: invalid SQL name \n\n<b>Call Example:</b>\n<pre>\n   SELECT TVDAssert.valid_sql_name('TEST') from dual;\n   SELECT TVDAssert.valid_sql_name('123') from dual\n</pre>\n*/",
            "title": "Example"
        },
        {
            "location": "/4-language-usage/1-general/g-1010/",
            "text": "G-1010: Try to label your sub blocks.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt's a good alternative for comments to indicate the start and end of a named processing.\n\n\nExample (bad)\n\n\nBEGIN\n   BEGIN \n      NULL;\n   END;\n\n   BEGIN\n      NULL;\n   END;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN\n   <<prepare_data>>\n   BEGIN \n      NULL;\n   END prepare_data;\n\n   <<process_data>>\n   BEGIN\n      NULL;\n   END process_data;\nEND good;\n/",
            "title": "G-1010: Try to label your sub blocks."
        },
        {
            "location": "/4-language-usage/1-general/g-1010/#g-1010-try-to-label-your-sub-blocks",
            "text": "Minor  Maintainability",
            "title": "G-1010: Try to label your sub blocks."
        },
        {
            "location": "/4-language-usage/1-general/g-1010/#reason",
            "text": "It's a good alternative for comments to indicate the start and end of a named processing.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1010/#example-bad",
            "text": "BEGIN\n   BEGIN \n      NULL;\n   END;\n\n   BEGIN\n      NULL;\n   END;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1010/#example-good",
            "text": "BEGIN\n   <<prepare_data>>\n   BEGIN \n      NULL;\n   END prepare_data;\n\n   <<process_data>>\n   BEGIN\n      NULL;\n   END process_data;\nEND good;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/1-general/g-1020/",
            "text": "G-1020: Always have a matching loop or block label.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nUse a label directly in front of loops and nested anonymous blocks:\n\n\n\n\nTo give a name to that portion of code and thereby self-document what it is doing.\n\n\nSo that you can repeat that name with the END statement of that block or loop.\n\n\n\n\nExample (bad)\n\n\nDECLARE\n   i INTEGER;\n   co_min_value CONSTANT INTEGER := 1;\n   co_max_value CONSTANT INTEGER := 10;\n   co_increment CONSTANT INTEGER := 1;\nBEGIN\n   <<prepare_data>>\n   BEGIN \n      NULL;\n   END;\n\n   <<process_data>>\n   BEGIN\n      NULL;\n   END;\n\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   i INTEGER;\n   co_min_value CONSTANT INTEGER := 1;\n   co_max_value CONSTANT INTEGER := 10;\n   co_increment CONSTANT INTEGER := 1;\nBEGIN\n   <<prepare_data>>\n   BEGIN \n      NULL;\n   END prepare_data;\n\n   <<process_data>>\n   BEGIN\n      NULL;\n   END process_data;\n\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n     sys.dbms_output.put_line(i);\n   END LOOP for_loop;\nEND;\n/",
            "title": "G-1020: Always have a matching loop or block label."
        },
        {
            "location": "/4-language-usage/1-general/g-1020/#g-1020-always-have-a-matching-loop-or-block-label",
            "text": "Minor  Maintainability",
            "title": "G-1020: Always have a matching loop or block label."
        },
        {
            "location": "/4-language-usage/1-general/g-1020/#reason",
            "text": "Use a label directly in front of loops and nested anonymous blocks:   To give a name to that portion of code and thereby self-document what it is doing.  So that you can repeat that name with the END statement of that block or loop.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1020/#example-bad",
            "text": "DECLARE\n   i INTEGER;\n   co_min_value CONSTANT INTEGER := 1;\n   co_max_value CONSTANT INTEGER := 10;\n   co_increment CONSTANT INTEGER := 1;\nBEGIN\n   <<prepare_data>>\n   BEGIN \n      NULL;\n   END;\n\n   <<process_data>>\n   BEGIN\n      NULL;\n   END;\n\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1020/#example-good",
            "text": "DECLARE\n   i INTEGER;\n   co_min_value CONSTANT INTEGER := 1;\n   co_max_value CONSTANT INTEGER := 10;\n   co_increment CONSTANT INTEGER := 1;\nBEGIN\n   <<prepare_data>>\n   BEGIN \n      NULL;\n   END prepare_data;\n\n   <<process_data>>\n   BEGIN\n      NULL;\n   END process_data;\n\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n     sys.dbms_output.put_line(i);\n   END LOOP for_loop;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/1-general/g-1030/",
            "text": "G-1030: Avoid defining variables that are not used.\n\n\n\n\nMinor\n\n\nEfficiency, Maintainability\n\n\n\n\nReason\n\n\nUnused variables decrease the maintainability and readability of your code.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  employees.last_name%TYPE;\n      l_first_name employees.first_name%TYPE;\n      co_department_id CONSTANT departments.department_id%TYPE := 10;\n      e_good EXCEPTION;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE e.department_id = co_department_id;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle_no_data_found;\n      WHEN too_many_rows THEN null; -- handle_too_many_rows;\n   END my_proc;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  employees.last_name%TYPE;\n      co_department_id CONSTANT departments.department_id%TYPE := 10;\n      e_good EXCEPTION;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE e.department_id = co_department_id;\n\n      RAISE e_good;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle_no_data_found;\n      WHEN too_many_rows THEN null; -- handle_too_many_rows;\n   END my_proc;\nEND my_package;\n/",
            "title": "G-1030: Avoid defining variables that are not used."
        },
        {
            "location": "/4-language-usage/1-general/g-1030/#g-1030-avoid-defining-variables-that-are-not-used",
            "text": "Minor  Efficiency, Maintainability",
            "title": "G-1030: Avoid defining variables that are not used."
        },
        {
            "location": "/4-language-usage/1-general/g-1030/#reason",
            "text": "Unused variables decrease the maintainability and readability of your code.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1030/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  employees.last_name%TYPE;\n      l_first_name employees.first_name%TYPE;\n      co_department_id CONSTANT departments.department_id%TYPE := 10;\n      e_good EXCEPTION;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE e.department_id = co_department_id;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle_no_data_found;\n      WHEN too_many_rows THEN null; -- handle_too_many_rows;\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1030/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  employees.last_name%TYPE;\n      co_department_id CONSTANT departments.department_id%TYPE := 10;\n      e_good EXCEPTION;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE e.department_id = co_department_id;\n\n      RAISE e_good;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle_no_data_found;\n      WHEN too_many_rows THEN null; -- handle_too_many_rows;\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/1-general/g-1040/",
            "text": "G-1040: Avoid dead code.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nAny part of your code, which is no longer used or cannot be reached, should be eliminated from your programs to simplify the code.\n\n\nExample (bad)\n\n\nDECLARE\n   co_dept_purchasing CONSTANT departments.department_id%TYPE := 30;\nBEGIN\n   IF 2=3 THEN\n      NULL; -- some dead code here\n   END IF;\n\n   NULL; -- some enabled code here\n\n   <<my_loop>>\n   LOOP\n      EXIT my_loop;    \n      NULL; -- some dead code here\n   END LOOP my_loop;\n\n   NULL; -- some other enabled code here\n\n   CASE \n      WHEN 1 = 1 AND 'x' = 'y' THEN\n         NULL; -- some dead code here\n      ELSE\n         NULL; -- some further enabled code here\n   END CASE;\n\n   <<my_loop2>>\n   FOR r_emp IN (SELECT last_name\n                   FROM employees\n                  WHERE department_id = co_dept_purchasing\n                     OR commission_pct IS NOT NULL \n                    AND 5=6) \n                -- \"OR commission_pct IS NOT NULL\" is dead code \n   LOOP\n      SYS.dbms_output.put_line(r_emp.last_name);\n   END LOOP my_loop2;\n\n   RETURN;\n   NULL; -- some dead code here\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_dept_admin CONSTANT dept.deptno%TYPE := 10;\nBEGIN\n   NULL; -- some enabled code here\n   NULL; -- some other enabled code here\n   NULL; -- some further enabled code here\n\n   <<my_loop2>>\n   FOR r_emp IN (SELECT last_name\n                   FROM employees\n                  WHERE department_id = co_dept_admin\n                     OR commission_pct IS NOT NULL) \n   LOOP\n      sys.dbms_output.put_line(r_emp.last_name);\n   END LOOP my_loop2;\nEND;\n/",
            "title": "G-1040: Avoid dead code."
        },
        {
            "location": "/4-language-usage/1-general/g-1040/#g-1040-avoid-dead-code",
            "text": "Minor  Maintainability",
            "title": "G-1040: Avoid dead code."
        },
        {
            "location": "/4-language-usage/1-general/g-1040/#reason",
            "text": "Any part of your code, which is no longer used or cannot be reached, should be eliminated from your programs to simplify the code.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1040/#example-bad",
            "text": "DECLARE\n   co_dept_purchasing CONSTANT departments.department_id%TYPE := 30;\nBEGIN\n   IF 2=3 THEN\n      NULL; -- some dead code here\n   END IF;\n\n   NULL; -- some enabled code here\n\n   <<my_loop>>\n   LOOP\n      EXIT my_loop;    \n      NULL; -- some dead code here\n   END LOOP my_loop;\n\n   NULL; -- some other enabled code here\n\n   CASE \n      WHEN 1 = 1 AND 'x' = 'y' THEN\n         NULL; -- some dead code here\n      ELSE\n         NULL; -- some further enabled code here\n   END CASE;\n\n   <<my_loop2>>\n   FOR r_emp IN (SELECT last_name\n                   FROM employees\n                  WHERE department_id = co_dept_purchasing\n                     OR commission_pct IS NOT NULL \n                    AND 5=6) \n                -- \"OR commission_pct IS NOT NULL\" is dead code \n   LOOP\n      SYS.dbms_output.put_line(r_emp.last_name);\n   END LOOP my_loop2;\n\n   RETURN;\n   NULL; -- some dead code here\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1040/#example-good",
            "text": "DECLARE\n   co_dept_admin CONSTANT dept.deptno%TYPE := 10;\nBEGIN\n   NULL; -- some enabled code here\n   NULL; -- some other enabled code here\n   NULL; -- some further enabled code here\n\n   <<my_loop2>>\n   FOR r_emp IN (SELECT last_name\n                   FROM employees\n                  WHERE department_id = co_dept_admin\n                     OR commission_pct IS NOT NULL) \n   LOOP\n      sys.dbms_output.put_line(r_emp.last_name);\n   END LOOP my_loop2;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/1-general/g-1050/",
            "text": "G-1050: Avoid using literals in your code.\n\n\n\n\nMinor\n\n\nChangeability\n\n\n\n\nReason\n\n\nLiterals are often used more than once in your code. Having them defined as a constant reduces typos in your code and improves the maintainability.\n\n\nAll constants should be collated in just one package used as a library. If these constants should be used in SQL too it is good practice to write a deterministic package function for every constant.\n\n\nExample (bad)\n\n\nDECLARE\n   l_job employees.job_id%TYPE;\nBEGIN\n   SELECT e.job_id\n     INTO l_job\n     FROM employees e\n    WHERE e.manager_id IS NULL;\n\n   IF l_job = 'AD_PRES' THEN\n      NULL;\n   END IF;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN \n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN \n      NULL; -- handle_too_many_rows; \nEND;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE constants_up IS\n   co_president CONSTANT employees.job_id%TYPE := 'AD_PRES';\nEND constants_up;\n/\n\nDECLARE\n   l_job employees.job_id%TYPE;\nBEGIN\n   SELECT e.job_id\n     INTO l_job\n     FROM employees e\n    WHERE e.manager_id IS NULL;\n\n   IF l_job = constants_up.co_president THEN\n      NULL;\n   END IF;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN \n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN \n      NULL; -- handle_too_many_rows; \nEND;\n/",
            "title": "G-1050: Avoid using literals in your code."
        },
        {
            "location": "/4-language-usage/1-general/g-1050/#g-1050-avoid-using-literals-in-your-code",
            "text": "Minor  Changeability",
            "title": "G-1050: Avoid using literals in your code."
        },
        {
            "location": "/4-language-usage/1-general/g-1050/#reason",
            "text": "Literals are often used more than once in your code. Having them defined as a constant reduces typos in your code and improves the maintainability.  All constants should be collated in just one package used as a library. If these constants should be used in SQL too it is good practice to write a deterministic package function for every constant.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1050/#example-bad",
            "text": "DECLARE\n   l_job employees.job_id%TYPE;\nBEGIN\n   SELECT e.job_id\n     INTO l_job\n     FROM employees e\n    WHERE e.manager_id IS NULL;\n\n   IF l_job = 'AD_PRES' THEN\n      NULL;\n   END IF;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN \n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN \n      NULL; -- handle_too_many_rows; \nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1050/#example-good",
            "text": "CREATE OR REPLACE PACKAGE constants_up IS\n   co_president CONSTANT employees.job_id%TYPE := 'AD_PRES';\nEND constants_up;\n/\n\nDECLARE\n   l_job employees.job_id%TYPE;\nBEGIN\n   SELECT e.job_id\n     INTO l_job\n     FROM employees e\n    WHERE e.manager_id IS NULL;\n\n   IF l_job = constants_up.co_president THEN\n      NULL;\n   END IF;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN \n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN \n      NULL; -- handle_too_many_rows; \nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/1-general/g-1060/",
            "text": "G-1060: Avoid storing ROWIDs or UROWIDs in database tables.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nIt is an extremely dangerous practice to store ROWIDs in a table, except for some very limited scenarios of runtime duration. Any manually explicit or system generated implicit table reorganization will reassign the row's ROWID and break the data consistency.\n\n\nInstead of using ROWID for later reference to the original row one should use the primary key column(s).\n\n\nExample (bad)\n\n\nBEGIN\n   INSERT INTO employees_log (employee_id\n                             ,last_name\n                             ,first_name\n                             ,rid)\n   SELECT employee_id \n         ,last_name\n         ,first_name\n         ,ROWID\n     FROM employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN\n   INSERT INTO employees_log (employee_id\n                             ,last_name\n                             ,first_name)\n   SELECT employee_id \n         ,last_name\n         ,first_name\n     FROM employees;\nEND;\n/",
            "title": "G-1060: Avoid storing ROWIDs or UROWIDs in database tables."
        },
        {
            "location": "/4-language-usage/1-general/g-1060/#g-1060-avoid-storing-rowids-or-urowids-in-database-tables",
            "text": "Major  Reliability",
            "title": "G-1060: Avoid storing ROWIDs or UROWIDs in database tables."
        },
        {
            "location": "/4-language-usage/1-general/g-1060/#reason",
            "text": "It is an extremely dangerous practice to store ROWIDs in a table, except for some very limited scenarios of runtime duration. Any manually explicit or system generated implicit table reorganization will reassign the row's ROWID and break the data consistency.  Instead of using ROWID for later reference to the original row one should use the primary key column(s).",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1060/#example-bad",
            "text": "BEGIN\n   INSERT INTO employees_log (employee_id\n                             ,last_name\n                             ,first_name\n                             ,rid)\n   SELECT employee_id \n         ,last_name\n         ,first_name\n         ,ROWID\n     FROM employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1060/#example-good",
            "text": "BEGIN\n   INSERT INTO employees_log (employee_id\n                             ,last_name\n                             ,first_name)\n   SELECT employee_id \n         ,last_name\n         ,first_name\n     FROM employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/1-general/g-1070/",
            "text": "G-1070: Avoid nesting comment blocks.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nHaving an end-of-comment within a block comment will end that block-comment. This does not only influence your code but is also very hard to read.\n\n\nExample (bad)\n\n\nBEGIN\n   /* comment one -- nested comment two */\n   NULL;\n   -- comment three /* nested comment four */\n   NULL;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN\n   /* comment one, comment two */\n   NULL;\n   -- comment three, comment four\n   NULL;\nEND;\n/",
            "title": "G-1070: Avoid nesting comment blocks."
        },
        {
            "location": "/4-language-usage/1-general/g-1070/#g-1070-avoid-nesting-comment-blocks",
            "text": "Minor  Maintainability",
            "title": "G-1070: Avoid nesting comment blocks."
        },
        {
            "location": "/4-language-usage/1-general/g-1070/#reason",
            "text": "Having an end-of-comment within a block comment will end that block-comment. This does not only influence your code but is also very hard to read.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/1-general/g-1070/#example-bad",
            "text": "BEGIN\n   /* comment one -- nested comment two */\n   NULL;\n   -- comment three /* nested comment four */\n   NULL;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/1-general/g-1070/#example-good",
            "text": "BEGIN\n   /* comment one, comment two */\n   NULL;\n   -- comment three, comment four\n   NULL;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2110/",
            "text": "G-2110: Try to use anchored declarations for variables, constants and types.\n\n\n\n\nMajor\n\n\nMaintainability, Reliability\n\n\n\n\nReason\n\n\nChanging the size of the database column last_name in the employees table from \nVARCHAR2(20)\n to \nVARCHAR2(30)\n will result in an error within your code whenever a value larger than the hard coded size is read from the table. This can be avoided using anchored declarations.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  VARCHAR2(20 CHAR);\n      co_first_row CONSTANT INTEGER := 1;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE rownum = co_first_row;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle no_data_found\n      WHEN too_many_rows THEN NULL; -- handle too_many_rows (impossible)\n   END my_proc;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  employees.last_name%TYPE;\n      co_first_row CONSTANT INTEGER := 1;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE rownum = co_first_row;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle no_data_found\n      WHEN too_many_rows THEN NULL; -- handle too_many_rows (impossible)\n   END my_proc;\nEND my_package;\n/",
            "title": "G-2110: Try to use anchored declarations for variables, constants and types."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2110/#g-2110-try-to-use-anchored-declarations-for-variables-constants-and-types",
            "text": "Major  Maintainability, Reliability",
            "title": "G-2110: Try to use anchored declarations for variables, constants and types."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2110/#reason",
            "text": "Changing the size of the database column last_name in the employees table from  VARCHAR2(20)  to  VARCHAR2(30)  will result in an error within your code whenever a value larger than the hard coded size is read from the table. This can be avoided using anchored declarations.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2110/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  VARCHAR2(20 CHAR);\n      co_first_row CONSTANT INTEGER := 1;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE rownum = co_first_row;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle no_data_found\n      WHEN too_many_rows THEN NULL; -- handle too_many_rows (impossible)\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2110/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_last_name  employees.last_name%TYPE;\n      co_first_row CONSTANT INTEGER := 1;\n   BEGIN\n      SELECT e.last_name\n        INTO l_last_name\n        FROM employees e\n       WHERE rownum = co_first_row;\n   EXCEPTION\n      WHEN no_data_found THEN NULL; -- handle no_data_found\n      WHEN too_many_rows THEN NULL; -- handle too_many_rows (impossible)\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2120/",
            "text": "G-2120: Try to have a single location to define your types.\n\n\n\n\nMinor\n\n\nChangeability\n\n\n\n\nReason\n\n\nSingle point of change when changing the data type. No need to argue where to define types or where to look for existing definitions.\n\n\nA single location could be either a type specification package or the database (database-defined types).\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);\n      l_note big_string_type;\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);\nEND types_up;\n/\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_note types_up.big_string_type;\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/",
            "title": "G-2120: Try to have a single location to define your types."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2120/#g-2120-try-to-have-a-single-location-to-define-your-types",
            "text": "Minor  Changeability",
            "title": "G-2120: Try to have a single location to define your types."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2120/#reason",
            "text": "Single point of change when changing the data type. No need to argue where to define types or where to look for existing definitions.  A single location could be either a type specification package or the database (database-defined types).",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2120/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);\n      l_note big_string_type;\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2120/#example-good",
            "text": "CREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);\nEND types_up;\n/\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_note types_up.big_string_type;\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2130/",
            "text": "G-2130: Try to use subtypes for constructs used often in your code.\n\n\n\n\nMinor\n\n\nChangeability\n\n\n\n\nReason\n\n\nSingle point of change when changing the data type.\n\n\nYour code will be easier to read as the usage of a variable/constant may be derived from its definition.\n\n\nExamples of possible subtype definitions\n\n\n\n\n\n\n\n\nType\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nora_name_type\n\n\nObject corresponding to the ORACLE naming conventions (table, variable, column, package, etc.).\n\n\n\n\n\n\nmax_vc2_type\n\n\nString variable with maximal VARCHAR2 size.\n\n\n\n\n\n\narray_index_type\n\n\nBest fitting data type for array navigation.\n\n\n\n\n\n\nid_type\n\n\nData type used for all primary key (id) columns.\n\n\n\n\n\n\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_note VARCHAR2(1000 CHAR);\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);\nEND types_up;\n/\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_note types_up.big_string_type;\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/",
            "title": "G-2130: Try to use subtypes for constructs used often in your code."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2130/#g-2130-try-to-use-subtypes-for-constructs-used-often-in-your-code",
            "text": "Minor  Changeability",
            "title": "G-2130: Try to use subtypes for constructs used often in your code."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2130/#reason",
            "text": "Single point of change when changing the data type.  Your code will be easier to read as the usage of a variable/constant may be derived from its definition.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2130/#examples-of-possible-subtype-definitions",
            "text": "Type  Usage      ora_name_type  Object corresponding to the ORACLE naming conventions (table, variable, column, package, etc.).    max_vc2_type  String variable with maximal VARCHAR2 size.    array_index_type  Best fitting data type for array navigation.    id_type  Data type used for all primary key (id) columns.",
            "title": "Examples of possible subtype definitions"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2130/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_note VARCHAR2(1000 CHAR);\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2130/#example-good",
            "text": "CREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);\nEND types_up;\n/\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_proc IS\n      l_note types_up.big_string_type;\n   BEGIN\n      l_note := some_function();\n   END my_proc;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2140/",
            "text": "G-2140: Never initialize variables with NULL.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nVariables are initialized to NULL by default.\n\n\nExample (bad)\n\n\nDECLARE\n   l_note big_string_type := NULL;\nBEGIN\n   sys.dbms_output.put_line(l_note);\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_note big_string_type;\nBEGIN\n   sys.dbms_output.put_line(l_note);\nEND;\n/",
            "title": "G-2140: Never initialize variables with NULL."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2140/#g-2140-never-initialize-variables-with-null",
            "text": "Minor  Maintainability",
            "title": "G-2140: Never initialize variables with NULL."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2140/#reason",
            "text": "Variables are initialized to NULL by default.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2140/#example-bad",
            "text": "DECLARE\n   l_note big_string_type := NULL;\nBEGIN\n   sys.dbms_output.put_line(l_note);\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2140/#example-good",
            "text": "DECLARE\n   l_note big_string_type;\nBEGIN\n   sys.dbms_output.put_line(l_note);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2150/",
            "text": "G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL.\n\n\n\n\nBlocker\n\n\nPortability, Reliability\n\n\n\n\nReason\n\n\nThe NULL value can cause confusion both from the standpoint of code review and code execution. You must always use the \nIS NULL\n or \nIS NOT NULL\n syntax when you need to check if a value is or is not \nNULL\n.\n\n\nExample (bad)\n\n\nDECLARE\n   l_value INTEGER;\nBEGIN\n   IF l_value = NULL THEN\n      NULL;\n   END IF;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_value INTEGER;\nBEGIN\n   IF l_value IS NULL THEN\n      NULL;\n   END IF;\nEND;\n/",
            "title": "G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2150/#g-2150-avoid-comparisons-with-null-value-consider-using-is-not-null",
            "text": "Blocker  Portability, Reliability",
            "title": "G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2150/#reason",
            "text": "The NULL value can cause confusion both from the standpoint of code review and code execution. You must always use the  IS NULL  or  IS NOT NULL  syntax when you need to check if a value is or is not  NULL .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2150/#example-bad",
            "text": "DECLARE\n   l_value INTEGER;\nBEGIN\n   IF l_value = NULL THEN\n      NULL;\n   END IF;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2150/#example-good",
            "text": "DECLARE\n   l_value INTEGER;\nBEGIN\n   IF l_value IS NULL THEN\n      NULL;\n   END IF;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2160/",
            "text": "G-2160: Avoid initializing variables using functions in the declaration section.\n\n\n\n\nCritical\n\n\nReliability\n\n\n\n\nReason\n\n\nIf your initialization fails, you will not be able to handle the error in your exceptions block.\n\n\nExample (bad)\n\n\nDECLARE\n   co_department_id CONSTANT INTEGER := 100;\n   l_department_name departments.department_name%TYPE := \n      department_api.name_by_id(in_id => co_department_id);\nBEGIN\n   sys.dbms_output.put_line(l_department_name);\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_department_id  CONSTANT INTEGER := 100;\n   co_unkown_name    CONSTANT departments.department_name%TYPE := 'unknown';\n   l_department_name departments.department_name%TYPE;\nBEGIN\n   <<init>>\n   BEGIN\n      l_department_name := department_api.name_by_id(in_id => co_department_id);\n   EXCEPTION\n      WHEN value_error THEN\n         l_department_name := co_unkown_name;\n   END init;\n\n   sys.dbms_output.put_line(l_department_name);\nEND;\n/",
            "title": "G-2160: Avoid initializing variables using functions in the declaration section."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2160/#g-2160-avoid-initializing-variables-using-functions-in-the-declaration-section",
            "text": "Critical  Reliability",
            "title": "G-2160: Avoid initializing variables using functions in the declaration section."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2160/#reason",
            "text": "If your initialization fails, you will not be able to handle the error in your exceptions block.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2160/#example-bad",
            "text": "DECLARE\n   co_department_id CONSTANT INTEGER := 100;\n   l_department_name departments.department_name%TYPE := \n      department_api.name_by_id(in_id => co_department_id);\nBEGIN\n   sys.dbms_output.put_line(l_department_name);\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2160/#example-good",
            "text": "DECLARE\n   co_department_id  CONSTANT INTEGER := 100;\n   co_unkown_name    CONSTANT departments.department_name%TYPE := 'unknown';\n   l_department_name departments.department_name%TYPE;\nBEGIN\n   <<init>>\n   BEGIN\n      l_department_name := department_api.name_by_id(in_id => co_department_id);\n   EXCEPTION\n      WHEN value_error THEN\n         l_department_name := co_unkown_name;\n   END init;\n\n   sys.dbms_output.put_line(l_department_name);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2170/",
            "text": "G-2170: Never overload variables.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nThe readability of your code will be higher when you do not overload variables.\n\n\nExample (bad)\n\n\nBEGIN \n   <<main>>\n   DECLARE\n      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';\n      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';\n      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';\n      l_variable user_objects.object_name%TYPE := co_main;\n   BEGIN\n      <<sub>>\n      DECLARE\n         l_variable user_objects.object_name%TYPE := co_sub;\n      BEGIN\n         sys.dbms_output.put_line(l_variable || co_sep || main.l_variable);\n      END sub;\n   END main;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN \n   <<main>>\n   DECLARE\n      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';\n      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';\n      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';\n      l_main_variable user_objects.object_name%TYPE := co_main;\n   BEGIN\n      <<sub>>\n      DECLARE\n         l_sub_variable user_objects.object_name%TYPE := co_sub;\n      BEGIN\n         sys.dbms_output.put_line(l_sub_variable || co_sep || l_main_variable);\n      END sub;\n   END main;\nEND;\n/",
            "title": "G-2170: Never overload variables."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2170/#g-2170-never-overload-variables",
            "text": "Major  Reliability",
            "title": "G-2170: Never overload variables."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2170/#reason",
            "text": "The readability of your code will be higher when you do not overload variables.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2170/#example-bad",
            "text": "BEGIN \n   <<main>>\n   DECLARE\n      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';\n      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';\n      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';\n      l_variable user_objects.object_name%TYPE := co_main;\n   BEGIN\n      <<sub>>\n      DECLARE\n         l_variable user_objects.object_name%TYPE := co_sub;\n      BEGIN\n         sys.dbms_output.put_line(l_variable || co_sep || main.l_variable);\n      END sub;\n   END main;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2170/#example-good",
            "text": "BEGIN \n   <<main>>\n   DECLARE\n      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';\n      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';\n      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';\n      l_main_variable user_objects.object_name%TYPE := co_main;\n   BEGIN\n      <<sub>>\n      DECLARE\n         l_sub_variable user_objects.object_name%TYPE := co_sub;\n      BEGIN\n         sys.dbms_output.put_line(l_sub_variable || co_sep || l_main_variable);\n      END sub;\n   END main;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2180/",
            "text": "G-2180: Never use quoted identifiers.\n\n\n\n\nMajor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nQuoted identifiers make your code hard to read and maintain.\n\n\nExample (bad)\n\n\nDECLARE\n   \"sal+comm\" INTEGER;\n   \"my constant\" CONSTANT INTEGER := 1;\n   \"my exception\" EXCEPTION;\nBEGIN\n   \"sal+comm\" := \"my constant\";\nEXCEPTION\n   WHEN \"my exception\" THEN\n      NULL;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_sal_comm     INTEGER;\n   co_my_constant CONSTANT INTEGER := 1;\n   e_my_exception EXCEPTION;   \nBEGIN\n   l_sal_comm := co_my_constant;\nEXCEPTION\n   WHEN e_my_exception THEN\n      NULL;\nEND;\n/",
            "title": "G-2180: Never use quoted identifiers."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2180/#g-2180-never-use-quoted-identifiers",
            "text": "Major  Maintainability",
            "title": "G-2180: Never use quoted identifiers."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2180/#reason",
            "text": "Quoted identifiers make your code hard to read and maintain.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2180/#example-bad",
            "text": "DECLARE\n   \"sal+comm\" INTEGER;\n   \"my constant\" CONSTANT INTEGER := 1;\n   \"my exception\" EXCEPTION;\nBEGIN\n   \"sal+comm\" := \"my constant\";\nEXCEPTION\n   WHEN \"my exception\" THEN\n      NULL;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2180/#example-good",
            "text": "DECLARE\n   l_sal_comm     INTEGER;\n   co_my_constant CONSTANT INTEGER := 1;\n   e_my_exception EXCEPTION;   \nBEGIN\n   l_sal_comm := co_my_constant;\nEXCEPTION\n   WHEN e_my_exception THEN\n      NULL;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2185/",
            "text": "G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nYou should ensure that the name you have chosen well defines its purpose and usage. While you can save a few keystrokes typing very short names, the resulting code is obscure and hard for anyone besides the author to understand.\n\n\nExample (bad)\n\n\nDECLARE\n   i INTEGER;\n   c CONSTANT INTEGER := 1;\n   e EXCEPTION;   \nBEGIN\n   i := c;\nEXCEPTION\n   WHEN e THEN\n      NULL;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_sal_comm     INTEGER;\n   co_my_constant CONSTANT INTEGER := 1;\n   e_my_exception EXCEPTION;   \nBEGIN\n   l_sal_comm := co_my_constant;\nEXCEPTION\n   WHEN e_my_exception THEN\n      NULL;\nEND;\n/",
            "title": "G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2185/#g-2185-avoid-using-overly-short-names-for-explicitly-or-implicitly-declared-identifiers",
            "text": "Minor  Maintainability",
            "title": "G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2185/#reason",
            "text": "You should ensure that the name you have chosen well defines its purpose and usage. While you can save a few keystrokes typing very short names, the resulting code is obscure and hard for anyone besides the author to understand.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2185/#example-bad",
            "text": "DECLARE\n   i INTEGER;\n   c CONSTANT INTEGER := 1;\n   e EXCEPTION;   \nBEGIN\n   i := c;\nEXCEPTION\n   WHEN e THEN\n      NULL;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2185/#example-good",
            "text": "DECLARE\n   l_sal_comm     INTEGER;\n   co_my_constant CONSTANT INTEGER := 1;\n   e_my_exception EXCEPTION;   \nBEGIN\n   l_sal_comm := co_my_constant;\nEXCEPTION\n   WHEN e_my_exception THEN\n      NULL;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2190/",
            "text": "G-2190: Avoid using ROWID or UROWID.\n\n\n\n\nMajor\n\n\nPortability, Reliability\n\n\n\n\nReason\n\n\nBe careful about your use of Oracle-specific data types like \nROWID\n and \nUROWID\n. They might offer a slight improvement in performance over other means of identifying a single row (primary key or unique index value), but that is by no means guaranteed. \n\n\nUse of \nROWID\n or \nUROWID\n means that your SQL statement will not be portable to other SQL databases. Many developers are also not familiar with these data types, which can make the code harder to maintain. \n\n\nExample (bad)\n\n\nDECLARE\n   l_department_name departments.department_name%TYPE;\n   l_rowid ROWID;\nBEGIN\n   UPDATE departments \n      SET department_name = l_department_name\n    WHERE ROWID = l_rowid;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_department_name  departments.department_name%TYPE;\n   l_department_id    departments.department_id%TYPE;\nBEGIN\n   UPDATE departments \n      SET department_name = l_department_name\n    WHERE department_id = l_department_id;\nEND;\n/",
            "title": "G-2190: Avoid using ROWID or UROWID."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2190/#g-2190-avoid-using-rowid-or-urowid",
            "text": "Major  Portability, Reliability",
            "title": "G-2190: Avoid using ROWID or UROWID."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2190/#reason",
            "text": "Be careful about your use of Oracle-specific data types like  ROWID  and  UROWID . They might offer a slight improvement in performance over other means of identifying a single row (primary key or unique index value), but that is by no means guaranteed.   Use of  ROWID  or  UROWID  means that your SQL statement will not be portable to other SQL databases. Many developers are also not familiar with these data types, which can make the code harder to maintain.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2190/#example-bad",
            "text": "DECLARE\n   l_department_name departments.department_name%TYPE;\n   l_rowid ROWID;\nBEGIN\n   UPDATE departments \n      SET department_name = l_department_name\n    WHERE ROWID = l_rowid;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/1-general/g-2190/#example-good",
            "text": "DECLARE\n   l_department_name  departments.department_name%TYPE;\n   l_department_id    departments.department_id%TYPE;\nBEGIN\n   UPDATE departments \n      SET department_name = l_department_name\n    WHERE department_id = l_department_id;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/",
            "text": "G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision.\n\n\n\n\nMinor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nIf you do not specify precision \nNUMBER\n is defaulted to 38 or the maximum supported by your system, whichever is less. You may well need all this precision, but if you know you do not, you should specify whatever matches your needs.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_small_increase CONSTANT NUMBER := 0.1;\n\n   FUNCTION small_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_small_increase;\n   END small_increase;\nEND constants_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_small_increase CONSTANT NUMBER(5,1) := 0.1;\n\n   FUNCTION small_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_small_increase;\n   END small_increase;\nEND constants_up;\n/",
            "title": "G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#g-2210-avoid-declaring-number-variables-constants-or-subtypes-with-no-precision",
            "text": "Minor  Efficiency",
            "title": "G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#reason",
            "text": "If you do not specify precision  NUMBER  is defaulted to 38 or the maximum supported by your system, whichever is less. You may well need all this precision, but if you know you do not, you should specify whatever matches your needs.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_small_increase CONSTANT NUMBER := 0.1;\n\n   FUNCTION small_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_small_increase;\n   END small_increase;\nEND constants_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2210/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_small_increase CONSTANT NUMBER(5,1) := 0.1;\n\n   FUNCTION small_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_small_increase;\n   END small_increase;\nEND constants_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/",
            "text": "G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values.\n\n\n\n\nMinor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nPLS_INTEGER\n having a length of -2,147,483,648 to 2,147,483,647, on a 32bit system.\n\n\nThere are many reasons to use \nPLS_INTEGER\n instead of \nNUMBER\n:\n\n\n\n\nPLS_INTEGER\n uses less memory\n\n\nPLS_INTEGER\n uses machine arithmetic, which is up to three times faster than library arithmetic, which is used by \nNUMBER\n.\n\n\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT NUMBER(5,0) := 1;\n\n   FUNCTION big_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT PLS_INTEGER := 1;\n\n   FUNCTION big_increase RETURN PLS_INTEGER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/",
            "title": "G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#g-2220-try-to-use-pls_integer-instead-of-number-for-arithmetic-operations-with-integer-values",
            "text": "Minor  Efficiency",
            "title": "G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#reason",
            "text": "PLS_INTEGER  having a length of -2,147,483,648 to 2,147,483,647, on a 32bit system.  There are many reasons to use  PLS_INTEGER  instead of  NUMBER :   PLS_INTEGER  uses less memory  PLS_INTEGER  uses machine arithmetic, which is up to three times faster than library arithmetic, which is used by  NUMBER .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT NUMBER(5,0) := 1;\n\n   FUNCTION big_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT PLS_INTEGER := 1;\n\n   FUNCTION big_increase RETURN PLS_INTEGER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/",
            "text": "G-2230: Try to use SIMPLE_INTEGER datatype when appropriate.\n\n\n\n\nMinor\n\n\nEfficiency\n\n\n\n\nRestriction\n\n\nORACLE 11g or later\n\n\nReason\n\n\nSIMPLE_INTEGER\n does no checks on numeric overflow, which results in better performance compared to the other numeric datatypes.\n\n\nWith ORACLE 11g, the new data type \nSIMPLE_INTEGER\n has been introduced. It is a sub-type of \nPLS_INTEGER\n and covers the same range. The basic difference is that \nSIMPLE_INTEGER\n is always \nNOT NULL\n.  When the value of the declared variable is never going to be null then you can declare it as \nSIMPLE_INTEGER\n. Another major difference is that you will never face a numeric overflow using \nSIMPLE_INTEGER\n as this data type wraps around without giving any error. \nSIMPLE_INTEGER\n data type gives major performance boost over \nPLS_INTEGER\n when code is compiled in \nNATIVE\n mode, because arithmetic operations on SIMPLE_INTEGER type are performed directly at the hardware level.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT NUMBER(5,0) := 1;\n\n   FUNCTION big_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT SIMPLE_INTEGER := 1;\n\n   FUNCTION big_increase RETURN SIMPLE_INTEGER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/",
            "title": "G-2230: Try to use SIMPLE_INTEGER datatype when appropriate."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#g-2230-try-to-use-simple_integer-datatype-when-appropriate",
            "text": "Minor  Efficiency",
            "title": "G-2230: Try to use SIMPLE_INTEGER datatype when appropriate."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#restriction",
            "text": "ORACLE 11g or later",
            "title": "Restriction"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#reason",
            "text": "SIMPLE_INTEGER  does no checks on numeric overflow, which results in better performance compared to the other numeric datatypes.  With ORACLE 11g, the new data type  SIMPLE_INTEGER  has been introduced. It is a sub-type of  PLS_INTEGER  and covers the same range. The basic difference is that  SIMPLE_INTEGER  is always  NOT NULL .  When the value of the declared variable is never going to be null then you can declare it as  SIMPLE_INTEGER . Another major difference is that you will never face a numeric overflow using  SIMPLE_INTEGER  as this data type wraps around without giving any error.  SIMPLE_INTEGER  data type gives major performance boost over  PLS_INTEGER  when code is compiled in  NATIVE  mode, because arithmetic operations on SIMPLE_INTEGER type are performed directly at the hardware level.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT NUMBER(5,0) := 1;\n\n   FUNCTION big_increase RETURN NUMBER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_big_increase CONSTANT SIMPLE_INTEGER := 1;\n\n   FUNCTION big_increase RETURN SIMPLE_INTEGER IS\n   BEGIN\n      RETURN co_big_increase;\n   END big_increase;\nEND constants_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2310/",
            "text": "G-2310: Avoid using CHAR data type.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nCHAR\n is a fixed length data type, which should only be used when appropriate. \nCHAR\n columns/variables are always filled to its specified lengths; this may lead to unwanted side effects and undesired results.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE types_up \nIS\n   SUBTYPE description_type IS CHAR(200);\nEND types_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE types_up \nIS\n   SUBTYPE description_type IS VARCHAR2(200 CHAR);\nEND types_up;\n/",
            "title": "G-2310: Avoid using CHAR data type."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#g-2310-avoid-using-char-data-type",
            "text": "Major  Reliability",
            "title": "G-2310: Avoid using CHAR data type."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#reason",
            "text": "CHAR  is a fixed length data type, which should only be used when appropriate.  CHAR  columns/variables are always filled to its specified lengths; this may lead to unwanted side effects and undesired results.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE types_up \nIS\n   SUBTYPE description_type IS CHAR(200);\nEND types_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2310/#example-good",
            "text": "CREATE OR REPLACE PACKAGE types_up \nIS\n   SUBTYPE description_type IS VARCHAR2(200 CHAR);\nEND types_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2320/",
            "text": "G-2320: Avoid using VARCHAR data type.\n\n\n\n\nMajor\n\n\nPortability\n\n\n\n\nReason\n\n\nDo not use the \nVARCHAR\n data type. Use the \nVARCHAR2\n data type instead. Although the \nVARCHAR\n data type is currently synonymous with \nVARCHAR2\n, the \nVARCHAR\n data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR(200);\nEND types_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR2(200 CHAR);\nEND types_up;\n/",
            "title": "G-2320: Avoid using VARCHAR data type."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#g-2320-avoid-using-varchar-data-type",
            "text": "Major  Portability",
            "title": "G-2320: Avoid using VARCHAR data type."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#reason",
            "text": "Do not use the  VARCHAR  data type. Use the  VARCHAR2  data type instead. Although the  VARCHAR  data type is currently synonymous with  VARCHAR2 , the  VARCHAR  data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR(200);\nEND types_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2320/#example-good",
            "text": "CREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR2(200 CHAR);\nEND types_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2330/",
            "text": "G-2330: Never use zero-length strings to substitute NULL.\n\n\n\n\nMajor\n\n\nPortability\n\n\n\n\nReason\n\n\nToday zero-length strings and \nNULL\n are currently handled identical by ORACLE. There is no guarantee that this will still be the case in future releases, therefore if you mean \nNULL\n use \nNULL\n.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_null_string CONSTANT VARCHAR2(1) := '';\n\n   FUNCTION null_string RETURN VARCHAR2 IS \n   BEGIN\n       RETURN co_null_string;\n   END null_string;\nEND constants_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY constants_up IS\n\n   FUNCTION empty_string RETURN VARCHAR2 IS \n   BEGIN\n       RETURN NULL;\n   END empty_string;\nEND constants_up;\n/",
            "title": "G-2330: Never use zero-length strings to substitute NULL."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#g-2330-never-use-zero-length-strings-to-substitute-null",
            "text": "Major  Portability",
            "title": "G-2330: Never use zero-length strings to substitute NULL."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#reason",
            "text": "Today zero-length strings and  NULL  are currently handled identical by ORACLE. There is no guarantee that this will still be the case in future releases, therefore if you mean  NULL  use  NULL .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n   co_null_string CONSTANT VARCHAR2(1) := '';\n\n   FUNCTION null_string RETURN VARCHAR2 IS \n   BEGIN\n       RETURN co_null_string;\n   END null_string;\nEND constants_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2330/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY constants_up IS\n\n   FUNCTION empty_string RETURN VARCHAR2 IS \n   BEGIN\n       RETURN NULL;\n   END empty_string;\nEND constants_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2340/",
            "text": "G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored).\n\n\n\n\nMinor\n\n\nReliability\n\n\n\n\nReason\n\n\nChanges to the \nNLS_LENGTH_SEMANTIC\n will only be picked up by your code after a recompilation.\n\n\nIn a multibyte environment a \nVARCHAR2(10)\n definition may not necessarily hold 10 characters, when multibyte characters a part of the value that should be stored unless the definition was done using the char semantic.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR2(200);\nEND types_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR2(200 CHAR);\nEND types_up;\n/",
            "title": "G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored)."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#g-2340-always-define-your-varchar2-variables-using-char-semantic-if-not-defined-anchored",
            "text": "Minor  Reliability",
            "title": "G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored)."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#reason",
            "text": "Changes to the  NLS_LENGTH_SEMANTIC  will only be picked up by your code after a recompilation.  In a multibyte environment a  VARCHAR2(10)  definition may not necessarily hold 10 characters, when multibyte characters a part of the value that should be stored unless the definition was done using the char semantic.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR2(200);\nEND types_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/3-character-data-types/g-2340/#example-good",
            "text": "CREATE OR REPLACE PACKAGE types_up IS\n   SUBTYPE description_type IS VARCHAR2(200 CHAR);\nEND types_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/",
            "text": "G-2410: Try to use boolean data type for values with dual meaning.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nThe use of TRUE and FALSE clarifies that this is a boolean value and makes the code easier to read.\n\n\nExample (bad)\n\n\nDECLARE\n   co_newFile CONSTANT PLS_INTEGER := 1000;\n   co_oldFile CONSTANT PLS_INTEGER := 500;\n   l_bigger   PLS_INTEGER;\nBEGIN\n   IF co_newFile < co_oldFile THEN\n      l_bigger := constants_up.co_numeric_true;\n   ELSE\n      l_bigger := constants_up.co_numeric_false;\n   END IF;\nEND;\n/\n\n\n\n\nExample (better)\n\n\nDECLARE\n   co_newFile CONSTANT PLS_INTEGER := 1000;\n   co_oldFile CONSTANT PLS_INTEGER := 500;\n   l_bigger  BOOLEAN;\nBEGIN\n   IF co_newFile < co_oldFile THEN\n      l_bigger := TRUE;\n   ELSE\n      l_bigger := FALSE;\n   END IF;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_newFile CONSTANT PLS_INTEGER := 1000;\n   co_oldFile CONSTANT PLS_INTEGER := 500;\n   l_bigger  BOOLEAN;\nBEGIN\n   l_bigger := NVL(co_newFile < co_oldFile,FALSE);\nEND;\n/",
            "title": "G-2410: Try to use boolean data type for values with dual meaning."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#g-2410-try-to-use-boolean-data-type-for-values-with-dual-meaning",
            "text": "Minor  Maintainability",
            "title": "G-2410: Try to use boolean data type for values with dual meaning."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#reason",
            "text": "The use of TRUE and FALSE clarifies that this is a boolean value and makes the code easier to read.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example-bad",
            "text": "DECLARE\n   co_newFile CONSTANT PLS_INTEGER := 1000;\n   co_oldFile CONSTANT PLS_INTEGER := 500;\n   l_bigger   PLS_INTEGER;\nBEGIN\n   IF co_newFile < co_oldFile THEN\n      l_bigger := constants_up.co_numeric_true;\n   ELSE\n      l_bigger := constants_up.co_numeric_false;\n   END IF;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example-better",
            "text": "DECLARE\n   co_newFile CONSTANT PLS_INTEGER := 1000;\n   co_oldFile CONSTANT PLS_INTEGER := 500;\n   l_bigger  BOOLEAN;\nBEGIN\n   IF co_newFile < co_oldFile THEN\n      l_bigger := TRUE;\n   ELSE\n      l_bigger := FALSE;\n   END IF;\nEND;\n/",
            "title": "Example (better)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example-good",
            "text": "DECLARE\n   co_newFile CONSTANT PLS_INTEGER := 1000;\n   co_oldFile CONSTANT PLS_INTEGER := 500;\n   l_bigger  BOOLEAN;\nBEGIN\n   l_bigger := NVL(co_newFile < co_oldFile,FALSE);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/5-large-objects/g-2510/",
            "text": "G-2510: Avoid using the LONG and LONG RAW data types.\n\n\n\n\nMajor\n\n\nPortability\n\n\n\n\nReason\n\n\nLONG\n and \nLONG RAW\n data types have been deprecated by ORACLE since version 8i - support might be discontinued in future ORACLE releases.\n\n\nThere are many constraints to LONG datatypes in comparison to the LOB types.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE example_package IS\n   g_long LONG;\n   g_raw  LONG RAW;\n\n   PROCEDURE do_something;\nEND example_package;\n/\n\nCREATE OR REPLACE PACKAGE BODY example_package IS\n   PROCEDURE do_something IS\n   BEGIN \n      NULL;\n   END do_something;\nEND example_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE example_package IS\n   PROCEDURE do_something;\nEND example_package;\n/\n\nCREATE OR REPLACE PACKAGE BODY example_package IS\n   g_long CLOB;\n   g_raw  BLOB;\n\n   PROCEDURE do_something IS\n   BEGIN \n      NULL;\n   END do_something;\nEND example_package;\n/",
            "title": "G-2510: Avoid using the LONG and LONG RAW data types."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/5-large-objects/g-2510/#g-2510-avoid-using-the-long-and-long-raw-data-types",
            "text": "Major  Portability",
            "title": "G-2510: Avoid using the LONG and LONG RAW data types."
        },
        {
            "location": "/4-language-usage/2-variables-and-types/5-large-objects/g-2510/#reason",
            "text": "LONG  and  LONG RAW  data types have been deprecated by ORACLE since version 8i - support might be discontinued in future ORACLE releases.  There are many constraints to LONG datatypes in comparison to the LOB types.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/5-large-objects/g-2510/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE example_package IS\n   g_long LONG;\n   g_raw  LONG RAW;\n\n   PROCEDURE do_something;\nEND example_package;\n/\n\nCREATE OR REPLACE PACKAGE BODY example_package IS\n   PROCEDURE do_something IS\n   BEGIN \n      NULL;\n   END do_something;\nEND example_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/2-variables-and-types/5-large-objects/g-2510/#example-good",
            "text": "CREATE OR REPLACE PACKAGE example_package IS\n   PROCEDURE do_something;\nEND example_package;\n/\n\nCREATE OR REPLACE PACKAGE BODY example_package IS\n   g_long CLOB;\n   g_raw  BLOB;\n\n   PROCEDURE do_something IS\n   BEGIN \n      NULL;\n   END do_something;\nEND example_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3110/",
            "text": "G-3110: Always specify the target columns when coding an insert statement.\n\n\n\n\nMajor\n\n\nMaintainability, Reliability\n\n\n\n\nReason\n\n\nData structures often change. Having the target columns in your insert statements will lead to change-resistant code.\n\n\nExample (bad)\n\n\nINSERT INTO departments\n     VALUES (departments_seq.nextval\n            ,'Support'\n            ,100\n            ,10);\n\n\n\n\nExample (good)\n\n\nINSERT INTO departments (department_id \n                        ,department_name\n                        ,manager_id\n                        ,location_id)\n     VALUES (departments_seq.nextval\n            ,'Support'\n            ,100\n            ,10);",
            "title": "G-3110: Always specify the target columns when coding an insert statement."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3110/#g-3110-always-specify-the-target-columns-when-coding-an-insert-statement",
            "text": "Major  Maintainability, Reliability",
            "title": "G-3110: Always specify the target columns when coding an insert statement."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3110/#reason",
            "text": "Data structures often change. Having the target columns in your insert statements will lead to change-resistant code.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3110/#example-bad",
            "text": "INSERT INTO departments\n     VALUES (departments_seq.nextval\n            ,'Support'\n            ,100\n            ,10);",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3110/#example-good",
            "text": "INSERT INTO departments (department_id \n                        ,department_name\n                        ,manager_id\n                        ,location_id)\n     VALUES (departments_seq.nextval\n            ,'Support'\n            ,100\n            ,10);",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/",
            "text": "G-3120: Always use table aliases when your SQL statement involves more than one source.\n\n\n\n\nMajor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt is more human readable to use aliases instead of writing columns with no table information.\n\n\nEspecially when using subqueries the omission of table aliases may end in unexpected behavior and result. \n\n\nExample (bad)\n\n\nSELECT last_name\n      ,first_name\n      ,department_name\n  FROM      employees  \n       JOIN departments USING (department_id)\n WHERE EXTRACT(MONTH FROM hire_date) = EXTRACT(MONTH FROM SYSDATE);\n\n\n\n\nExample (better)\n\n\nSELECT e.last_name\n      ,e.first_name\n      ,d.department_name\n  FROM      employees   e\n       JOIN departments d ON (e.department_id = d.department_id)\n WHERE EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);\n\n\n\n\nExample (good)\n\n\nUsing meaningful aliases improves the readability of your code.\n\n\nSELECT emp.last_name\n      ,emp.first_name\n      ,dept.department_name\n  FROM      employees   emp\n       JOIN departments dept ON (emp.department_id = dept.department_id)\n WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);\n\n\n\n\nExample Subquery (bad)\n\n\nIf the \njobs\n table has no \nemployee_id\n column and \nemployees\n has one this query will not raise an error but return all rows of the \nemployees\n table as a subquery is allowed to access columns of all its parent tables - this construct is known as correlated subquery.\n\n\nSELECT last_name\n      ,first_name\n  FROM employees\n WHERE employee_id IN (SELECT employee_id\n                         FROM jobs\n                        WHERE job_title like '%Manager%');\n\n\n\n\nExample Subquery (good)\n\n\nIf the \njobs\n table has no \nemployee_id\n column this query will return an error due to the directive (given by adding the table alias to the column) to read the \nemployee_id\n column from the \njobs\n table.\n\n\nSELECT emp.last_name\n      ,emp.first_name\n  FROM employees emp\n WHERE emp.employee_id IN (SELECT j.employee_id\n                             FROM jobs j\n                            WHERE j.job_title like '%Manager%');",
            "title": "G-3120: Always use table aliases when your SQL statement involves more than one source."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#g-3120-always-use-table-aliases-when-your-sql-statement-involves-more-than-one-source",
            "text": "Major  Maintainability",
            "title": "G-3120: Always use table aliases when your SQL statement involves more than one source."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#reason",
            "text": "It is more human readable to use aliases instead of writing columns with no table information.  Especially when using subqueries the omission of table aliases may end in unexpected behavior and result.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#example-bad",
            "text": "SELECT last_name\n      ,first_name\n      ,department_name\n  FROM      employees  \n       JOIN departments USING (department_id)\n WHERE EXTRACT(MONTH FROM hire_date) = EXTRACT(MONTH FROM SYSDATE);",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#example-better",
            "text": "SELECT e.last_name\n      ,e.first_name\n      ,d.department_name\n  FROM      employees   e\n       JOIN departments d ON (e.department_id = d.department_id)\n WHERE EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);",
            "title": "Example (better)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#example-good",
            "text": "Using meaningful aliases improves the readability of your code.  SELECT emp.last_name\n      ,emp.first_name\n      ,dept.department_name\n  FROM      employees   emp\n       JOIN departments dept ON (emp.department_id = dept.department_id)\n WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#example-subquery-bad",
            "text": "If the  jobs  table has no  employee_id  column and  employees  has one this query will not raise an error but return all rows of the  employees  table as a subquery is allowed to access columns of all its parent tables - this construct is known as correlated subquery.  SELECT last_name\n      ,first_name\n  FROM employees\n WHERE employee_id IN (SELECT employee_id\n                         FROM jobs\n                        WHERE job_title like '%Manager%');",
            "title": "Example Subquery (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3120/#example-subquery-good",
            "text": "If the  jobs  table has no  employee_id  column this query will return an error due to the directive (given by adding the table alias to the column) to read the  employee_id  column from the  jobs  table.  SELECT emp.last_name\n      ,emp.first_name\n  FROM employees emp\n WHERE emp.employee_id IN (SELECT j.employee_id\n                             FROM jobs j\n                            WHERE j.job_title like '%Manager%');",
            "title": "Example Subquery (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3130/",
            "text": "G-3130: Try to use ANSI SQL-92 join syntax.\n\n\n\n\nMinor\n\n\nMaintainability, Portability\n\n\n\n\nReason\n\n\nANSI SQL-92 join syntax supports the full outer join. A further advantage of the ANSI SQL-92 join syntax is the separation of the join condition from the query filters.\n\n\nExample (bad)\n\n\nSELECT e.employee_id\n      ,e.last_name\n      ,e.first_name\n      ,d.department_name\n  FROM employees e\n      ,departments d \n WHERE e.department_id = d.department_id\n   AND EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);\n\n\n\n\nExample (good)\n\n\nSELECT emp.employee_id\n      ,emp.last_name\n      ,emp.first_name\n      ,dept.department_name\n  FROM      employees   emp\n       JOIN departments dept ON dept.department_id = emp.department_id\n WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);",
            "title": "G-3130: Try to use ANSI SQL-92 join syntax."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3130/#g-3130-try-to-use-ansi-sql-92-join-syntax",
            "text": "Minor  Maintainability, Portability",
            "title": "G-3130: Try to use ANSI SQL-92 join syntax."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3130/#reason",
            "text": "ANSI SQL-92 join syntax supports the full outer join. A further advantage of the ANSI SQL-92 join syntax is the separation of the join condition from the query filters.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3130/#example-bad",
            "text": "SELECT e.employee_id\n      ,e.last_name\n      ,e.first_name\n      ,d.department_name\n  FROM employees e\n      ,departments d \n WHERE e.department_id = d.department_id\n   AND EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3130/#example-good",
            "text": "SELECT emp.employee_id\n      ,emp.last_name\n      ,emp.first_name\n      ,dept.department_name\n  FROM      employees   emp\n       JOIN departments dept ON dept.department_id = emp.department_id\n WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3140/",
            "text": "G-3140: Try to use anchored records as targets for your cursors.\n\n\n\n\nMajor\n\n\nMaintainability, Reliability\n\n\n\n\nReason\n\n\nUsing cursor-anchored records as targets for your cursors results enables the possibility of changing the structure of the cursor without regard to the target structure.\n\n\nExample (bad)\n\n\nDECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, first_name, last_name\n        FROM employees;\n   l_employee_id employees.employee_id%TYPE;\n   l_first_name  employees.first_name%TYPE;\n   l_last_name   employees.last_name%TYPE;\nBEGIN\n   OPEN c_employees;\n   FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;\n   <<process_employees>>\n   WHILE c_employees%FOUND\n   LOOP\n      -- do something with the data\n      FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;\n   END LOOP process_employees;\n   CLOSE c_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, first_name, last_name\n        FROM employees;\n   r_employee c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n   FETCH c_employees INTO r_employee;\n   <<process_employees>>\n   WHILE c_employees%FOUND\n   LOOP\n      -- do something with the data\n      FETCH c_employees INTO r_employee;\n   END LOOP process_employees;\n   CLOSE c_employees;\nEND;\n/",
            "title": "G-3140: Try to use anchored records as targets for your cursors."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3140/#g-3140-try-to-use-anchored-records-as-targets-for-your-cursors",
            "text": "Major  Maintainability, Reliability",
            "title": "G-3140: Try to use anchored records as targets for your cursors."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3140/#reason",
            "text": "Using cursor-anchored records as targets for your cursors results enables the possibility of changing the structure of the cursor without regard to the target structure.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3140/#example-bad",
            "text": "DECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, first_name, last_name\n        FROM employees;\n   l_employee_id employees.employee_id%TYPE;\n   l_first_name  employees.first_name%TYPE;\n   l_last_name   employees.last_name%TYPE;\nBEGIN\n   OPEN c_employees;\n   FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;\n   <<process_employees>>\n   WHILE c_employees%FOUND\n   LOOP\n      -- do something with the data\n      FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;\n   END LOOP process_employees;\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3140/#example-good",
            "text": "DECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, first_name, last_name\n        FROM employees;\n   r_employee c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n   FETCH c_employees INTO r_employee;\n   <<process_employees>>\n   WHILE c_employees%FOUND\n   LOOP\n      -- do something with the data\n      FETCH c_employees INTO r_employee;\n   END LOOP process_employees;\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3150/",
            "text": "G-3150: Try to use identity columns for surrogate keys.\n\n\n\n\nMinor\n\n\nMaintainability, Reliability\n\n\n\n\nRestriction\n\n\nORACLE 12c\n\n\nReason\n\n\nAn identity column is a surrogate key by design \u2013 there is no reason why we should not take advantage of this natural implementation when the keys are generated on database level. Using identity column (and therefore assigning sequences as default values on columns) has a huge performance advantage over a trigger solution.\n\n\nExample (bad)\n\n\nCREATE TABLE locations (\n   location_id        NUMBER(10)        NOT NULL \n  ,location_name      VARCHAR2(60 CHAR) NOT NULL\n  ,city               VARCHAR2(30 CHAR) NOT NULL\n  ,CONSTRAINT locations_pk PRIMARY KEY (location_id)\n  )\n/\n\nCREATE SEQUENCE location_seq START WITH 1 CACHE 20\n/\n\nCREATE OR REPLACE TRIGGER location_br_i \n   BEFORE INSERT ON LOCATIONS \n   FOR EACH ROW \nBEGIN\n   :new.location_id := location_seq.nextval;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nCREATE TABLE locations (\n   location_id        NUMBER(10)  GENERATED ALWAYS AS IDENTITY \n  ,location_name      VARCHAR2(60 CHAR) NOT NULL\n  ,city               VARCHAR2(30 CHAR) NOT NULL\n  ,CONSTRAINT locations_pk PRIMARY KEY (location_id))\n/",
            "title": "G-3150: Try to use identity columns for surrogate keys."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3150/#g-3150-try-to-use-identity-columns-for-surrogate-keys",
            "text": "Minor  Maintainability, Reliability",
            "title": "G-3150: Try to use identity columns for surrogate keys."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3150/#restriction",
            "text": "ORACLE 12c",
            "title": "Restriction"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3150/#reason",
            "text": "An identity column is a surrogate key by design \u2013 there is no reason why we should not take advantage of this natural implementation when the keys are generated on database level. Using identity column (and therefore assigning sequences as default values on columns) has a huge performance advantage over a trigger solution.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3150/#example-bad",
            "text": "CREATE TABLE locations (\n   location_id        NUMBER(10)        NOT NULL \n  ,location_name      VARCHAR2(60 CHAR) NOT NULL\n  ,city               VARCHAR2(30 CHAR) NOT NULL\n  ,CONSTRAINT locations_pk PRIMARY KEY (location_id)\n  )\n/\n\nCREATE SEQUENCE location_seq START WITH 1 CACHE 20\n/\n\nCREATE OR REPLACE TRIGGER location_br_i \n   BEFORE INSERT ON LOCATIONS \n   FOR EACH ROW \nBEGIN\n   :new.location_id := location_seq.nextval;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3150/#example-good",
            "text": "CREATE TABLE locations (\n   location_id        NUMBER(10)  GENERATED ALWAYS AS IDENTITY \n  ,location_name      VARCHAR2(60 CHAR) NOT NULL\n  ,city               VARCHAR2(30 CHAR) NOT NULL\n  ,CONSTRAINT locations_pk PRIMARY KEY (location_id))\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3160/",
            "text": "G-3160: Avoid virtual columns to be visible.\n\n\n\n\nMajor\n\n\nMaintainability, Reliability\n\n\n\n\nRestriction\n\n\nORACLE 12c\n\n\nReason\n\n\nIn contrast to visible columns, invisible columns are not part of a record defined using \n%ROWTYPE\n construct. This is helpful as a virtual column may not be programmatically populated. If your virtual column is visible you have to manually define the record types used in API packages to be able to exclude them from being part of the record definition.\n\n\nInvisible columns may be accessed by explicitly adding them to the column list in a SELECT statement.\n\n\nExample (bad)\n\n\nALTER TABLE employees\n   ADD total_salary GENERATED ALWAYS AS (salary + NVL(commission_pct,0) * salary)\n/\n\nDECLARE\n   r_employee employees%ROWTYPE;\n   l_id employees.employee_id%TYPE := 107;\nBEGIN\n   r_employee := employee_api.employee_by_id(l_id);\n   r_employee.salary := r_employee.salary * constants_up.small_increase();\n\n   UPDATE employees\n      SET ROW = r_employee\n    WHERE employee_id = l_id;\nEND;\n/\n\nError report -\nORA-54017: UPDATE operation disallowed ON virtual COLUMNS\nORA-06512: at line 9\n\n\n\n\nExample (good)\n\n\nALTER TABLE employees\n   ADD total_salary INVISIBLE GENERATED ALWAYS AS \n      (salary + NVL(commission_pct,0) * salary)\n/\n\nDECLARE\n   r_employee employees%ROWTYPE;\n   co_id CONSTANT employees.employee_id%TYPE := 107;\nBEGIN\n   r_employee := employee_api.employee_by_id(co_id);\n   r_employee.salary := r_employee.salary * constants_up.small_increase();\n\n   UPDATE employees\n      SET ROW = r_employee\n    WHERE employee_id = co_id;\nEND;\n/",
            "title": "G-3160: Avoid virtual columns to be visible."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3160/#g-3160-avoid-virtual-columns-to-be-visible",
            "text": "Major  Maintainability, Reliability",
            "title": "G-3160: Avoid virtual columns to be visible."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3160/#restriction",
            "text": "ORACLE 12c",
            "title": "Restriction"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3160/#reason",
            "text": "In contrast to visible columns, invisible columns are not part of a record defined using  %ROWTYPE  construct. This is helpful as a virtual column may not be programmatically populated. If your virtual column is visible you have to manually define the record types used in API packages to be able to exclude them from being part of the record definition.  Invisible columns may be accessed by explicitly adding them to the column list in a SELECT statement.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3160/#example-bad",
            "text": "ALTER TABLE employees\n   ADD total_salary GENERATED ALWAYS AS (salary + NVL(commission_pct,0) * salary)\n/\n\nDECLARE\n   r_employee employees%ROWTYPE;\n   l_id employees.employee_id%TYPE := 107;\nBEGIN\n   r_employee := employee_api.employee_by_id(l_id);\n   r_employee.salary := r_employee.salary * constants_up.small_increase();\n\n   UPDATE employees\n      SET ROW = r_employee\n    WHERE employee_id = l_id;\nEND;\n/\n\nError report -\nORA-54017: UPDATE operation disallowed ON virtual COLUMNS\nORA-06512: at line 9",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3160/#example-good",
            "text": "ALTER TABLE employees\n   ADD total_salary INVISIBLE GENERATED ALWAYS AS \n      (salary + NVL(commission_pct,0) * salary)\n/\n\nDECLARE\n   r_employee employees%ROWTYPE;\n   co_id CONSTANT employees.employee_id%TYPE := 107;\nBEGIN\n   r_employee := employee_api.employee_by_id(co_id);\n   r_employee.salary := r_employee.salary * constants_up.small_increase();\n\n   UPDATE employees\n      SET ROW = r_employee\n    WHERE employee_id = co_id;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3170/",
            "text": "G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nRestriction\n\n\nORACLE 12c\n\n\nReason\n\n\nDefault values have been nullifiable until ORACLE 12c. Meaning any tool sending null as a value for a column having a default value bypassed the default value. Starting with ORACLE 12c default definitions may have an \nON NULL\n definition in addition, which will assign the default value in case of a null value too.\n\n\nExample (bad)\n\n\nCREATE TABLE null_test (\n   test_case        NUMBER(2) NOT NULL\n  ,column_defaulted VARCHAR2(10) DEFAULT 'Default')\n/\nINSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');\nINSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);\nINSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);\n\nSELECT * FROM null_test;\n\nTEST_CASE  COLUMN_DEF\n---------  -----------\n        1  Value\n        2  Default\n        3\n\n\n\n\nExample (good)\n\n\nCREATE TABLE null_test (\n   test_case        NUMBER(2) NOT NULL\n  ,column_defaulted VARCHAR2(10) DEFAULT ON NULL 'Default')\n/\nINSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');\nINSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);\nINSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);\n\nSELECT * FROM null_test;\n\n TEST_CASE COLUMN_DEF\n---------- ----------\n         1 Value     \n         2 Default   \n         3 Default",
            "title": "G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3170/#g-3170-always-use-default-on-null-declarations-to-assign-default-values-to-table-columns-if-you-refuse-to-store-null-values",
            "text": "Major  Reliability",
            "title": "G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3170/#restriction",
            "text": "ORACLE 12c",
            "title": "Restriction"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3170/#reason",
            "text": "Default values have been nullifiable until ORACLE 12c. Meaning any tool sending null as a value for a column having a default value bypassed the default value. Starting with ORACLE 12c default definitions may have an  ON NULL  definition in addition, which will assign the default value in case of a null value too.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3170/#example-bad",
            "text": "CREATE TABLE null_test (\n   test_case        NUMBER(2) NOT NULL\n  ,column_defaulted VARCHAR2(10) DEFAULT 'Default')\n/\nINSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');\nINSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);\nINSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);\n\nSELECT * FROM null_test;\n\nTEST_CASE  COLUMN_DEF\n---------  -----------\n        1  Value\n        2  Default\n        3",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3170/#example-good",
            "text": "CREATE TABLE null_test (\n   test_case        NUMBER(2) NOT NULL\n  ,column_defaulted VARCHAR2(10) DEFAULT ON NULL 'Default')\n/\nINSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');\nINSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);\nINSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);\n\nSELECT * FROM null_test;\n\n TEST_CASE COLUMN_DEF\n---------- ----------\n         1 Value     \n         2 Default   \n         3 Default",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3180/",
            "text": "G-3180: Always specify column names instead of positional references in ORDER BY clauses.\n\n\n\n\nMajor\n\n\nChangeability, Reliability\n\n\n\n\nReason\n\n\nIf you change your select list afterwards the ORDER BY will still work but order your rows differently, when not changing the positional number. Furthermore, it is not comfortable to the readers of the code, if they have to count the columns in the SELECT list to know the way the result is ordered.\n\n\nExample (bad)\n\n\nSELECT UPPER(first_name) \n      ,last_name \n      ,salary \n      ,hire_date \n  FROM employees\n ORDER BY 4,1,3;\n\n\n\n\nExample (good)\n\n\nSELECT upper(first_name) AS first_name  \n      ,last_name \n      ,salary \n      ,hire_date\n  FROM employees\n ORDER BY hire_date \n         ,first_name \n         ,salary;",
            "title": "G-3180: Always specify column names instead of positional references in ORDER BY clauses."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3180/#g-3180-always-specify-column-names-instead-of-positional-references-in-order-by-clauses",
            "text": "Major  Changeability, Reliability",
            "title": "G-3180: Always specify column names instead of positional references in ORDER BY clauses."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3180/#reason",
            "text": "If you change your select list afterwards the ORDER BY will still work but order your rows differently, when not changing the positional number. Furthermore, it is not comfortable to the readers of the code, if they have to count the columns in the SELECT list to know the way the result is ordered.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3180/#example-bad",
            "text": "SELECT UPPER(first_name) \n      ,last_name \n      ,salary \n      ,hire_date \n  FROM employees\n ORDER BY 4,1,3;",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3180/#example-good",
            "text": "SELECT upper(first_name) AS first_name  \n      ,last_name \n      ,salary \n      ,hire_date\n  FROM employees\n ORDER BY hire_date \n         ,first_name \n         ,salary;",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3190/",
            "text": "G-3190: Avoid using NATURAL JOIN.\n\n\n\n\nMajor\n\n\nChangeability, Reliability\n\n\n\n\nReason\n\n\nA natural join joins tables on equally named columns. This may comfortably fit on first sight, but adding logging columns to a table (changed_by, changed_date) will result in inappropriate join conditions. \n\n\nExample (bad)\n\n\nSELECT department_name \n      ,last_name \n      ,first_name \n  FROM employees NATURAL JOIN departments\n ORDER BY department_name \n         ,last_name;\nDEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         \n------------------------------ ------------------------- --------------------\nAccounting                     Gietz                     William             \nExecutive                      De Haan                   Lex                 \n\u2026\n\nALTER TABLE departments ADD modified_at DATE DEFAULT ON NULL SYSDATE;\nALTER TABLE employees ADD modified_at DATE DEFAULT ON NULL SYSDATE;\n\nSELECT department_name \n      ,last_name \n      ,first_name \n  FROM employees NATURAL JOIN departments\n ORDER BY department_name \n         ,last_name;\n\nNo data found\n\n\n\n\nExample (good)\n\n\nSELECT d.department_name \n      ,e.last_name \n      ,e.first_name \n  FROM employees   e\n  JOIN departments d ON (e.department_id = d.department_id)\n ORDER BY d.department_name \n         ,e.last_name;\n\nDEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         \n------------------------------ ------------------------- --------------------\nAccounting                     Gietz                     William             \nExecutive                      De Haan                   Lex                 \n\u2026",
            "title": "G-3190: Avoid using NATURAL JOIN."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3190/#g-3190-avoid-using-natural-join",
            "text": "Major  Changeability, Reliability",
            "title": "G-3190: Avoid using NATURAL JOIN."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3190/#reason",
            "text": "A natural join joins tables on equally named columns. This may comfortably fit on first sight, but adding logging columns to a table (changed_by, changed_date) will result in inappropriate join conditions.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3190/#example-bad",
            "text": "SELECT department_name \n      ,last_name \n      ,first_name \n  FROM employees NATURAL JOIN departments\n ORDER BY department_name \n         ,last_name;\nDEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         \n------------------------------ ------------------------- --------------------\nAccounting                     Gietz                     William             \nExecutive                      De Haan                   Lex                 \n\u2026\n\nALTER TABLE departments ADD modified_at DATE DEFAULT ON NULL SYSDATE;\nALTER TABLE employees ADD modified_at DATE DEFAULT ON NULL SYSDATE;\n\nSELECT department_name \n      ,last_name \n      ,first_name \n  FROM employees NATURAL JOIN departments\n ORDER BY department_name \n         ,last_name;\n\nNo data found",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/1-general/g-3190/#example-good",
            "text": "SELECT d.department_name \n      ,e.last_name \n      ,e.first_name \n  FROM employees   e\n  JOIN departments d ON (e.department_id = d.department_id)\n ORDER BY d.department_name \n         ,e.last_name;\n\nDEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         \n------------------------------ ------------------------- --------------------\nAccounting                     Gietz                     William             \nExecutive                      De Haan                   Lex                 \n\u2026",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/",
            "text": "G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times.\n\n\n\n\nMajor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nContext switches between PL/SQL and SQL are extremely costly. BULK Operations reduce the number of switches by passing an array to the SQL engine, which is used to execute the given statements repeatedly.\n\n\n(Depending on the PLSQL_OPTIMIZE_LEVEL parameter a conversion to BULK COLLECT will be done by the PL/SQL compiler automatically.)\n\n\nExample (bad)\n\n\nDECLARE\n   t_employee_ids employee_api.t_employee_ids_type;\n   co_increase CONSTANT employees.salary%type := 0.1;\n   co_department_id CONSTANT departments.department_id%TYPE := 10;\nBEGIN\n   t_employee_ids := employee_api.employee_ids_by_department(\n                        id_in => co_department_id\n                     );\n   <<process_employees>>\n   FOR i IN 1..t_employee_ids.COUNT()\n   LOOP\n      UPDATE employees\n         SET salary = salary + (salary * co_increase)\n       WHERE employee_id = t_employee_ids(i);\n   END LOOP process_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   t_employee_ids   employee_api.t_employee_ids_type;\n   co_increase      CONSTANT employees.salary%type := 0.1;\n   co_department_id CONSTANT departments.department_id%TYPE := 10;\nBEGIN\n   t_employee_ids := employee_api.employee_ids_by_department(\n                        id_in => co_department_id\n                     );\n   <<process_employees>>\n   FORALL i IN 1..t_employee_ids.COUNT()\n      UPDATE employees\n         SET salary = salary + (salary * co_increase)\n       WHERE employee_id = t_employee_ids(i);\nEND;\n/",
            "title": "G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#g-3210-always-use-bulk-operations-bulk-collect-forall-whenever-you-have-to-execute-a-dml-statement-for-more-than-4-times",
            "text": "Major  Efficiency",
            "title": "G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times."
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#reason",
            "text": "Context switches between PL/SQL and SQL are extremely costly. BULK Operations reduce the number of switches by passing an array to the SQL engine, which is used to execute the given statements repeatedly.  (Depending on the PLSQL_OPTIMIZE_LEVEL parameter a conversion to BULK COLLECT will be done by the PL/SQL compiler automatically.)",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#example-bad",
            "text": "DECLARE\n   t_employee_ids employee_api.t_employee_ids_type;\n   co_increase CONSTANT employees.salary%type := 0.1;\n   co_department_id CONSTANT departments.department_id%TYPE := 10;\nBEGIN\n   t_employee_ids := employee_api.employee_ids_by_department(\n                        id_in => co_department_id\n                     );\n   <<process_employees>>\n   FOR i IN 1..t_employee_ids.COUNT()\n   LOOP\n      UPDATE employees\n         SET salary = salary + (salary * co_increase)\n       WHERE employee_id = t_employee_ids(i);\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#example-good",
            "text": "DECLARE\n   t_employee_ids   employee_api.t_employee_ids_type;\n   co_increase      CONSTANT employees.salary%type := 0.1;\n   co_department_id CONSTANT departments.department_id%TYPE := 10;\nBEGIN\n   t_employee_ids := employee_api.employee_ids_by_department(\n                        id_in => co_department_id\n                     );\n   <<process_employees>>\n   FORALL i IN 1..t_employee_ids.COUNT()\n      UPDATE employees\n         SET salary = salary + (salary * co_increase)\n       WHERE employee_id = t_employee_ids(i);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4110/",
            "text": "G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nThe readability of your code will be higher when you avoid negative sentences.\n\n\nExample (bad)\n\n\nDECLARE\n   CURSOR c_employees IS \n      SELECT last_name\n            ,first_name\n        FROM employees\n       WHERE commission_pct IS NOT NULL;\n\n   r_employee  c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n\n   <<read_employees>>\n   LOOP\n      FETCH c_employees INTO r_employee;\n      EXIT read_employees WHEN NOT c_employees%FOUND;\n   END LOOP read_employees;\n\n   CLOSE c_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   CURSOR c_employees IS \n      SELECT last_name\n            ,first_name\n        FROM employees\n       WHERE commission_pct IS NOT NULL;\n\n   r_employee  c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n\n   <<read_employees>>\n   LOOP\n      FETCH c_employees INTO r_employee;\n      EXIT read_employees WHEN c_employees%NOTFOUND;\n   END LOOP read_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4110/#g-4110-always-use-notfound-instead-of-not-found-to-check-whether-a-cursor-returned-data",
            "text": "Minor  Maintainability",
            "title": "G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4110/#reason",
            "text": "The readability of your code will be higher when you avoid negative sentences.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4110/#example-bad",
            "text": "DECLARE\n   CURSOR c_employees IS \n      SELECT last_name\n            ,first_name\n        FROM employees\n       WHERE commission_pct IS NOT NULL;\n\n   r_employee  c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n\n   <<read_employees>>\n   LOOP\n      FETCH c_employees INTO r_employee;\n      EXIT read_employees WHEN NOT c_employees%FOUND;\n   END LOOP read_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4110/#example-good",
            "text": "DECLARE\n   CURSOR c_employees IS \n      SELECT last_name\n            ,first_name\n        FROM employees\n       WHERE commission_pct IS NOT NULL;\n\n   r_employee  c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n\n   <<read_employees>>\n   LOOP\n      FETCH c_employees INTO r_employee;\n      EXIT read_employees WHEN c_employees%NOTFOUND;\n   END LOOP read_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4120/",
            "text": "G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause.\n\n\n\n\nCritical\n\n\nReliability\n\n\n\n\nReason\n\n\n%NOTFOUND\n is set to \nTRUE\n as soon as less than the number of rows defined by the \nLIMIT\n clause has been read.\n\n\nExample (bad)\n\n\nThe employees table holds 107 rows. The example below will only show 100 rows as the cursor attribute \nNOTFOUND\n is set to true as soon as the number of rows to be fetched defined by the limit clause is not fulfilled anymore.\n\n\nDECLARE\n   CURSOR c_employees IS \n      SELECT *\n        FROM employees\n       ORDER BY employee_id;\n\n   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;\n   t_employees t_employees_type;\n   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;\nBEGIN\n   OPEN c_employees;\n\n   <<process_employees>>\n   LOOP\n      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;\n      EXIT process_employees WHEN c_employees%NOTFOUND;\n\n      <<display_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i).last_name);\n      END LOOP display_employees;\n   END LOOP process_employees;\n\n   CLOSE c_employees;\nEND;\n/\n\n\n\n\nExample (better)\n\n\nThis example will show all 107 rows but execute one fetch too much (12 instead of 11).\n\n\nDECLARE\n   CURSOR c_employees IS \n      SELECT *\n        FROM employees\n       ORDER BY employee_id;\n\n   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;\n   t_employees t_employees_type;\n   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;\nBEGIN\n   OPEN c_employees;\n\n   <<process_employees>>\n   LOOP\n      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;\n      EXIT process_employees WHEN t_employees.COUNT() = 0;\n      <<display_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i).last_name);\n      END LOOP display_employees;\n   END LOOP process_employees;\n\n   CLOSE c_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nThis example does the trick (11 fetches only to process all rows)\n\n\nDECLARE\n   CURSOR c_employees IS \n      SELECT *\n        FROM employees\n       ORDER BY employee_id;\n\n   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;\n   t_employees t_employees_type;\n   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;\nBEGIN\n   OPEN c_employees;\n\n   <<process_employees>>\n   LOOP\n      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;\n      <<display_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i).last_name);\n      END LOOP display_employees;\n      EXIT process_employees WHEN t_employees.COUNT() <> co_bulk_size;\n   END LOOP process_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4120/#g-4120-avoid-using-notfound-directly-after-the-fetch-when-working-with-bulk-operations-and-limit-clause",
            "text": "Critical  Reliability",
            "title": "G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4120/#reason",
            "text": "%NOTFOUND  is set to  TRUE  as soon as less than the number of rows defined by the  LIMIT  clause has been read.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4120/#example-bad",
            "text": "The employees table holds 107 rows. The example below will only show 100 rows as the cursor attribute  NOTFOUND  is set to true as soon as the number of rows to be fetched defined by the limit clause is not fulfilled anymore.  DECLARE\n   CURSOR c_employees IS \n      SELECT *\n        FROM employees\n       ORDER BY employee_id;\n\n   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;\n   t_employees t_employees_type;\n   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;\nBEGIN\n   OPEN c_employees;\n\n   <<process_employees>>\n   LOOP\n      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;\n      EXIT process_employees WHEN c_employees%NOTFOUND;\n\n      <<display_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i).last_name);\n      END LOOP display_employees;\n   END LOOP process_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4120/#example-better",
            "text": "This example will show all 107 rows but execute one fetch too much (12 instead of 11).  DECLARE\n   CURSOR c_employees IS \n      SELECT *\n        FROM employees\n       ORDER BY employee_id;\n\n   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;\n   t_employees t_employees_type;\n   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;\nBEGIN\n   OPEN c_employees;\n\n   <<process_employees>>\n   LOOP\n      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;\n      EXIT process_employees WHEN t_employees.COUNT() = 0;\n      <<display_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i).last_name);\n      END LOOP display_employees;\n   END LOOP process_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (better)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4120/#example-good",
            "text": "This example does the trick (11 fetches only to process all rows)  DECLARE\n   CURSOR c_employees IS \n      SELECT *\n        FROM employees\n       ORDER BY employee_id;\n\n   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;\n   t_employees t_employees_type;\n   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;\nBEGIN\n   OPEN c_employees;\n\n   <<process_employees>>\n   LOOP\n      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;\n      <<display_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i).last_name);\n      END LOOP display_employees;\n      EXIT process_employees WHEN t_employees.COUNT() <> co_bulk_size;\n   END LOOP process_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4130/",
            "text": "G-4130: Always close locally opened cursors.\n\n\n\n\nMajor\n\n\nEfficiency, Reliability\n\n\n\n\nReason\n\n\nAny cursors left open can consume additional memory space (i.e. SGA) within the database instance, potentially in both the shared and private SQL pools. Furthermore, failure to explicitly close cursors may also cause the owning session to exceed its maximum limit of open cursors (as specified by the \nOPEN_CURSORS\n database initialization parameter), potentially resulting in the Oracle error of \u201cORA-01000: maximum open cursors exceeded\u201d. \n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)\n      RETURN NUMBER IS\n      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS \n         SELECT sum(salary) AS sum_salary\n           FROM employees\n          WHERE department_id = p_dept_id;\n      r_department_salary c_department_salary%rowtype;\n   BEGIN\n      OPEN c_department_salary(p_dept_id => in_dept_id);\n      FETCH c_department_salary INTO r_department_salary;\n\n      RETURN r_department_salary.sum_salary;\n   END department_salary;\nEND employee_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)\n      RETURN NUMBER IS\n      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS \n         SELECT SUM(salary) AS sum_salary\n           FROM employees\n          WHERE department_id = p_dept_id;\n      r_department_salary c_department_salary%rowtype;\n   BEGIN\n      OPEN c_department_salary(p_dept_id => in_dept_id);\n      FETCH c_department_salary INTO r_department_salary;\n      CLOSE c_department_salary;\n      RETURN r_department_salary.sum_salary;\n   END department_salary;\nEND employee_api;\n/",
            "title": "G-4130: Always close locally opened cursors."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4130/#g-4130-always-close-locally-opened-cursors",
            "text": "Major  Efficiency, Reliability",
            "title": "G-4130: Always close locally opened cursors."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4130/#reason",
            "text": "Any cursors left open can consume additional memory space (i.e. SGA) within the database instance, potentially in both the shared and private SQL pools. Furthermore, failure to explicitly close cursors may also cause the owning session to exceed its maximum limit of open cursors (as specified by the  OPEN_CURSORS  database initialization parameter), potentially resulting in the Oracle error of \u201cORA-01000: maximum open cursors exceeded\u201d.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4130/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api AS\n   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)\n      RETURN NUMBER IS\n      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS \n         SELECT sum(salary) AS sum_salary\n           FROM employees\n          WHERE department_id = p_dept_id;\n      r_department_salary c_department_salary%rowtype;\n   BEGIN\n      OPEN c_department_salary(p_dept_id => in_dept_id);\n      FETCH c_department_salary INTO r_department_salary;\n\n      RETURN r_department_salary.sum_salary;\n   END department_salary;\nEND employee_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4130/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api AS\n   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)\n      RETURN NUMBER IS\n      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS \n         SELECT SUM(salary) AS sum_salary\n           FROM employees\n          WHERE department_id = p_dept_id;\n      r_department_salary c_department_salary%rowtype;\n   BEGIN\n      OPEN c_department_salary(p_dept_id => in_dept_id);\n      FETCH c_department_salary INTO r_department_salary;\n      CLOSE c_department_salary;\n      RETURN r_department_salary.sum_salary;\n   END department_salary;\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4140/",
            "text": "G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nOracle provides a variety of cursor attributes (like \n%FOUND\n and \n%ROWCOUNT\n) that can be used to obtain information about the status of a cursor, either implicit or explicit. \n\n\nYou should avoid inserting any statements between the cursor operation and the use of an attribute against that cursor. Interposing such a statement can affect the value returned by the attribute, thereby potentially corrupting the logic of your program. \n\n\nIn the following example, a procedure call is inserted between the DELETE statement and a check for the value of \nSQL%ROWCOUNT\n, which returns the number of rows modified by that last SQL statement executed in the session. If this procedure includes a \nCOMMIT\n / \nROLLBACK\n or another implicit cursor the value of \nSQL%ROWCOUNT\n is affected.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   co_one CONSTANT SIMPLE_INTEGER := 1;\n\n   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS\n   BEGIN\n      NULL;\n   END process_dept;\n\n   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS\n      l_dept_id      employees.department_id%TYPE;\n   BEGIN\n      DELETE FROM employees\n       WHERE employee_id = in_employee_id\n       RETURNING department_id INTO l_dept_id;\n\n      process_dept(in_dept_id => l_dept_id);\n\n      IF SQL%ROWCOUNT > co_one THEN\n         -- too many rows deleted. \n         ROLLBACK;\n      END IF;\n   END remove_employee;\nEND employee_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   co_one CONSTANT SIMPLE_INTEGER := 1;\n\n   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS\n   BEGIN\n      NULL;\n   END process_dept;\n\n   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS\n      l_dept_id      employees.department_id%TYPE;\n      l_deleted_emps SIMPLE_INTEGER;\n   BEGIN\n      DELETE FROM employees\n       WHERE employee_id = in_employee_id\n       RETURNING department_id INTO l_dept_id;\n\n      l_deleted_emps := SQL%ROWCOUNT;\n\n      process_dept(in_dept_id => l_dept_id);\n\n      IF l_deleted_emps > co_one THEN\n         -- too many rows deleted. \n         ROLLBACK;\n      END IF;\n   END remove_employee;\nEND employee_api;\n/",
            "title": "G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4140/#g-4140-avoid-executing-any-statements-between-a-sql-operation-and-the-usage-of-an-implicit-cursor-attribute",
            "text": "Major  Reliability",
            "title": "G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute."
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4140/#reason",
            "text": "Oracle provides a variety of cursor attributes (like  %FOUND  and  %ROWCOUNT ) that can be used to obtain information about the status of a cursor, either implicit or explicit.   You should avoid inserting any statements between the cursor operation and the use of an attribute against that cursor. Interposing such a statement can affect the value returned by the attribute, thereby potentially corrupting the logic of your program.   In the following example, a procedure call is inserted between the DELETE statement and a check for the value of  SQL%ROWCOUNT , which returns the number of rows modified by that last SQL statement executed in the session. If this procedure includes a  COMMIT  /  ROLLBACK  or another implicit cursor the value of  SQL%ROWCOUNT  is affected.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4140/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api AS\n   co_one CONSTANT SIMPLE_INTEGER := 1;\n\n   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS\n   BEGIN\n      NULL;\n   END process_dept;\n\n   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS\n      l_dept_id      employees.department_id%TYPE;\n   BEGIN\n      DELETE FROM employees\n       WHERE employee_id = in_employee_id\n       RETURNING department_id INTO l_dept_id;\n\n      process_dept(in_dept_id => l_dept_id);\n\n      IF SQL%ROWCOUNT > co_one THEN\n         -- too many rows deleted. \n         ROLLBACK;\n      END IF;\n   END remove_employee;\nEND employee_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/1-cursor/g-4140/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api AS\n   co_one CONSTANT SIMPLE_INTEGER := 1;\n\n   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS\n   BEGIN\n      NULL;\n   END process_dept;\n\n   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS\n      l_dept_id      employees.department_id%TYPE;\n      l_deleted_emps SIMPLE_INTEGER;\n   BEGIN\n      DELETE FROM employees\n       WHERE employee_id = in_employee_id\n       RETURNING department_id INTO l_dept_id;\n\n      l_deleted_emps := SQL%ROWCOUNT;\n\n      process_dept(in_dept_id => l_dept_id);\n\n      IF l_deleted_emps > co_one THEN\n         -- too many rows deleted. \n         ROLLBACK;\n      END IF;\n   END remove_employee;\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/",
            "text": "G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths.\n\n\n\n\nMajor\n\n\nMaintainability, Testability\n\n\n\n\nReason\n\n\nIF\n statements containing multiple \nELSIF\n tend to become complex quickly.\n\n\nExample (bad)\n\n\nDECLARE\n   l_color VARCHAR2(7 CHAR);\nBEGIN\n   IF l_color = constants_up.co_red THEN\n      my_package.do_red();\n   ELSIF l_color = constants_up.co_blue THEN\n      my_package.do_blue();\n   ELSIF l_color = constants_up.co_black THEN\n      my_package.do_black();\n   END IF;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_color types_up.color_code_type;\nBEGIN\n   CASE l_color\n      WHEN constants_up.co_red   THEN \n         my_package.do_red();\n      WHEN constants_up.co_blue  THEN \n         my_package.do_blue();\n      WHEN constants_up.co_black THEN \n         my_package.do_black();\n      ELSE NULL;\n   END CASE;\nEND;\n/",
            "title": "G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#g-4210-try-to-use-case-rather-than-an-if-statement-with-multiple-elsif-paths",
            "text": "Major  Maintainability, Testability",
            "title": "G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#reason",
            "text": "IF  statements containing multiple  ELSIF  tend to become complex quickly.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#example-bad",
            "text": "DECLARE\n   l_color VARCHAR2(7 CHAR);\nBEGIN\n   IF l_color = constants_up.co_red THEN\n      my_package.do_red();\n   ELSIF l_color = constants_up.co_blue THEN\n      my_package.do_blue();\n   ELSIF l_color = constants_up.co_black THEN\n      my_package.do_black();\n   END IF;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#example-good",
            "text": "DECLARE\n   l_color types_up.color_code_type;\nBEGIN\n   CASE l_color\n      WHEN constants_up.co_red   THEN \n         my_package.do_red();\n      WHEN constants_up.co_blue  THEN \n         my_package.do_blue();\n      WHEN constants_up.co_black THEN \n         my_package.do_black();\n      ELSE NULL;\n   END CASE;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/",
            "text": "G-4220: Try to use CASE rather than DECODE.\n\n\n\n\nMinor\n\n\nMaintainability, Portability\n\n\n\n\nReason\n\n\nDECODE\n is an ORACLE specific function hard to understand and restricted to SQL only. The \u201cnewer\u201d \nCASE\n function is much more common has a better readability and may be used within PL/SQL too.\n\n\nExample (bad)\n\n\nSELECT DECODE(dummy, 'X', 1 \n                      , 'Y', 2\n                      , 'Z', 3\n                      , 0)\n  FROM dual;\n\n\n\n\nExample (good)\n\n\nSELECT CASE dummy\n          WHEN 'X' THEN 1\n          WHEN 'Y' THEN 2\n          WHEN 'Z' THEN 3\n          ELSE 0\n       END\n  FROM dual;",
            "title": "G-4220: Try to use CASE rather than DECODE."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#g-4220-try-to-use-case-rather-than-decode",
            "text": "Minor  Maintainability, Portability",
            "title": "G-4220: Try to use CASE rather than DECODE."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#reason",
            "text": "DECODE  is an ORACLE specific function hard to understand and restricted to SQL only. The \u201cnewer\u201d  CASE  function is much more common has a better readability and may be used within PL/SQL too.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#example-bad",
            "text": "SELECT DECODE(dummy, 'X', 1 \n                      , 'Y', 2\n                      , 'Z', 3\n                      , 0)\n  FROM dual;",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#example-good",
            "text": "SELECT CASE dummy\n          WHEN 'X' THEN 1\n          WHEN 'Y' THEN 2\n          WHEN 'Z' THEN 3\n          ELSE 0\n       END\n  FROM dual;",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/",
            "text": "G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement.\n\n\n\n\nCritical\n\n\nEfficiency, Reliability\n\n\n\n\nReason\n\n\nThe \nNVL\n function always evaluates both parameters before deciding which one to use. This can be harmful if parameter 2 is either a function call or a select statement, as it will be executed regardless of whether parameter 1 contains a NULL value or not.\n\n\nThe \nCOALESCE\n function does not have this drawback.\n\n\nExample (bad)\n\n\nSELECT NVL(dummy, my_package.expensive_null(value_in => dummy))\n  FROM dual;\n\n\n\n\nExample (good)\n\n\nSELECT COALESCE(dummy, my_package.expensive_null(value_in => dummy))\n  FROM dual;",
            "title": "G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#g-4230-always-use-a-coalesce-instead-of-a-nvl-command-if-parameter-2-of-the-nvl-function-is-a-function-call-or-a-select-statement",
            "text": "Critical  Efficiency, Reliability",
            "title": "G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#reason",
            "text": "The  NVL  function always evaluates both parameters before deciding which one to use. This can be harmful if parameter 2 is either a function call or a select statement, as it will be executed regardless of whether parameter 1 contains a NULL value or not.  The  COALESCE  function does not have this drawback.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#example-bad",
            "text": "SELECT NVL(dummy, my_package.expensive_null(value_in => dummy))\n  FROM dual;",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#example-good",
            "text": "SELECT COALESCE(dummy, my_package.expensive_null(value_in => dummy))\n  FROM dual;",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/",
            "text": "G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement.\n\n\n\n\nCritical\n\n\nEfficiency, Reliability\n\n\n\n\nReason\n\n\nThe \nNVL2\n function always evaluates all parameters before deciding which one to use. This can be harmful, if parameter 2 or 3 is either a function call or a select statement, as they will be executed regardless of whether parameter 1 contains a \nNULL\n value or not.\n\n\nExample (bad)\n\n\nSELECT NVL2(dummy, my_package.expensive_nn(value_in => dummy), \n                   my_package.expensive_null(value_in => dummy))\n  FROM dual;\n\n\n\n\nExample (good)\n\n\nSELECT CASE\n          WHEN dummy IS NULL THEN \n             my_package.expensive_null(value_in => dummy)\n          ELSE \n             my_package.expensive_nn(value_in => dummy)\n       END\nFROM dual;",
            "title": "G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#g-4240-always-use-a-case-instead-of-a-nvl2-command-if-parameter-2-or-3-of-nvl2-is-either-a-function-call-or-a-select-statement",
            "text": "Critical  Efficiency, Reliability",
            "title": "G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement."
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#reason",
            "text": "The  NVL2  function always evaluates all parameters before deciding which one to use. This can be harmful, if parameter 2 or 3 is either a function call or a select statement, as they will be executed regardless of whether parameter 1 contains a  NULL  value or not.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#example-bad",
            "text": "SELECT NVL2(dummy, my_package.expensive_nn(value_in => dummy), \n                   my_package.expensive_null(value_in => dummy))\n  FROM dual;",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#example-good",
            "text": "SELECT CASE\n          WHEN dummy IS NULL THEN \n             my_package.expensive_null(value_in => dummy)\n          ELSE \n             my_package.expensive_nn(value_in => dummy)\n       END\nFROM dual;",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4310/",
            "text": "G-4310: Never use GOTO statements in your code.\n\n\n\n\nMajor\n\n\nMaintainability, Testability\n\n\n\n\nReason\n\n\nCode containing gotos is hard to format. Indentation should be used to show logical structure and gotos have an effect on logical structure. Trying to use indentation to show the logical structure of a goto, however, is difficult or impossible.\n\n\nUse of gotos is a matter of religion. In modern languages, you can easily replace nine out of ten gotos with equivalent structured constructs. In these simple cases, you should replace gotos out of habit. In the hard cases, \nyou can break the code into smaller routines; use nested ifs; test and retest a status variable; or restructure a conditional. Eliminating the goto is harder in these cases, but it's good mental exercise.\n\n\nExcerpt of \nUsing gotos by Steven C. McConnell\n.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE password_check (in_password IN VARCHAR2) IS \n      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';\n      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;\n      co_errno       CONSTANT SIMPLE_INTEGER := -20501;\n      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';\n      l_isdigit      BOOLEAN     := FALSE;\n      l_len_pw       PLS_INTEGER;\n      l_len_array    PLS_INTEGER;\n   BEGIN\n      l_len_pw    := LENGTH(in_password);\n      l_len_array := LENGTH(co_digitarray);\n\n      <<check_digit>>\n      FOR i IN co_lower_bound .. l_len_array\n      LOOP\n         <<check_pw_char>>\n         FOR j IN co_lower_bound .. l_len_pw\n         LOOP\n            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN\n               l_isdigit := TRUE;\n               GOTO check_other_things;\n            END IF;\n         END LOOP check_pw_char;\n      END LOOP check_digit;\n\n      <<check_other_things>>\n      NULL;\n\n      IF NOT l_isdigit THEN\n         raise_application_error(co_errno, co_errmsg);\n      END IF;\n   END password_check;\nEND my_package;\n/\n\n\n\n\nExample (better)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE password_check (in_password IN VARCHAR2) IS \n      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';\n      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;\n      co_errno       CONSTANT SIMPLE_INTEGER := -20501;\n      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';\n      l_isdigit      BOOLEAN     := FALSE;\n      l_len_pw       PLS_INTEGER;\n      l_len_array    PLS_INTEGER;\n   BEGIN\n      l_len_pw    := LENGTH(in_password);\n      l_len_array := LENGTH(co_digitarray);\n\n      <<check_digit>>\n      FOR i IN co_lower_bound .. l_len_array\n      LOOP\n         <<check_pw_char>>\n         FOR j IN co_lower_bound .. l_len_pw\n         LOOP\n            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN\n               l_isdigit := TRUE;\n               EXIT check_digit; -- early exit condition\n            END IF;\n         END LOOP check_pw_char;\n      END LOOP check_digit;\n\n      <<check_other_things>>\n      NULL;\n\n      IF NOT l_isdigit THEN\n         raise_application_error(co_errno, co_errmsg);\n      END IF;\n   END password_check;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE password_check (in_password IN VARCHAR2) IS\n      co_digitpattern CONSTANT STRING(10 CHAR)   := '\\d';\n      co_errno        CONSTANT SIMPLE_INTEGER := -20501;\n      co_errmsg       CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';\n   BEGIN\n      IF NOT REGEXP_LIKE(in_password, co_digitpattern) \n      THEN\n         raise_application_error(co_errno, co_errmsg);\n      END IF;\n   END password_check;\nEND my_package;\n/",
            "title": "G-4310: Never use GOTO statements in your code."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4310/#g-4310-never-use-goto-statements-in-your-code",
            "text": "Major  Maintainability, Testability",
            "title": "G-4310: Never use GOTO statements in your code."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4310/#reason",
            "text": "Code containing gotos is hard to format. Indentation should be used to show logical structure and gotos have an effect on logical structure. Trying to use indentation to show the logical structure of a goto, however, is difficult or impossible.  Use of gotos is a matter of religion. In modern languages, you can easily replace nine out of ten gotos with equivalent structured constructs. In these simple cases, you should replace gotos out of habit. In the hard cases, \nyou can break the code into smaller routines; use nested ifs; test and retest a status variable; or restructure a conditional. Eliminating the goto is harder in these cases, but it's good mental exercise.  Excerpt of  Using gotos by Steven C. McConnell .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4310/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE password_check (in_password IN VARCHAR2) IS \n      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';\n      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;\n      co_errno       CONSTANT SIMPLE_INTEGER := -20501;\n      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';\n      l_isdigit      BOOLEAN     := FALSE;\n      l_len_pw       PLS_INTEGER;\n      l_len_array    PLS_INTEGER;\n   BEGIN\n      l_len_pw    := LENGTH(in_password);\n      l_len_array := LENGTH(co_digitarray);\n\n      <<check_digit>>\n      FOR i IN co_lower_bound .. l_len_array\n      LOOP\n         <<check_pw_char>>\n         FOR j IN co_lower_bound .. l_len_pw\n         LOOP\n            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN\n               l_isdigit := TRUE;\n               GOTO check_other_things;\n            END IF;\n         END LOOP check_pw_char;\n      END LOOP check_digit;\n\n      <<check_other_things>>\n      NULL;\n\n      IF NOT l_isdigit THEN\n         raise_application_error(co_errno, co_errmsg);\n      END IF;\n   END password_check;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4310/#example-better",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE password_check (in_password IN VARCHAR2) IS \n      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';\n      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;\n      co_errno       CONSTANT SIMPLE_INTEGER := -20501;\n      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';\n      l_isdigit      BOOLEAN     := FALSE;\n      l_len_pw       PLS_INTEGER;\n      l_len_array    PLS_INTEGER;\n   BEGIN\n      l_len_pw    := LENGTH(in_password);\n      l_len_array := LENGTH(co_digitarray);\n\n      <<check_digit>>\n      FOR i IN co_lower_bound .. l_len_array\n      LOOP\n         <<check_pw_char>>\n         FOR j IN co_lower_bound .. l_len_pw\n         LOOP\n            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN\n               l_isdigit := TRUE;\n               EXIT check_digit; -- early exit condition\n            END IF;\n         END LOOP check_pw_char;\n      END LOOP check_digit;\n\n      <<check_other_things>>\n      NULL;\n\n      IF NOT l_isdigit THEN\n         raise_application_error(co_errno, co_errmsg);\n      END IF;\n   END password_check;\nEND my_package;\n/",
            "title": "Example (better)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4310/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE password_check (in_password IN VARCHAR2) IS\n      co_digitpattern CONSTANT STRING(10 CHAR)   := '\\d';\n      co_errno        CONSTANT SIMPLE_INTEGER := -20501;\n      co_errmsg       CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';\n   BEGIN\n      IF NOT REGEXP_LIKE(in_password, co_digitpattern) \n      THEN\n         raise_application_error(co_errno, co_errmsg);\n      END IF;\n   END password_check;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4320/",
            "text": "G-4320: Always label your loops.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt's a good alternative for comments to indicate the start and end of a named loop processing.\n\n\nExample (bad)\n\n\nDECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP;\n\n   LOOP \n      EXIT;\n   END LOOP;\n\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP;\n\n   FOR r_employee IN (SELECT last_name FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP;   \nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\n\n   <<process_employees>>\n   FOR r_employee IN (SELECT last_name\n                        FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP process_employees;\nEND;\n/",
            "title": "G-4320: Always label your loops."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4320/#g-4320-always-label-your-loops",
            "text": "Minor  Maintainability",
            "title": "G-4320: Always label your loops."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4320/#reason",
            "text": "It's a good alternative for comments to indicate the start and end of a named loop processing.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4320/#example-bad",
            "text": "DECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP;\n\n   LOOP \n      EXIT;\n   END LOOP;\n\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP;\n\n   FOR r_employee IN (SELECT last_name FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP;   \nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4320/#example-good",
            "text": "DECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\n\n   <<process_employees>>\n   FOR r_employee IN (SELECT last_name\n                        FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4330/",
            "text": "G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt is easier for the reader to see, that the complete data set is processed. Using SQL to define the data to be processed is easier to maintain and typically faster than using conditional processing within the loop.\n\n\nSince an \nEXIT\n statement is similar to a \nGOTO\n statement, \nit should be avoided, whenever possible.\n\n\nExample (bad)\n\n\nDECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\n   r_employee c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n\n   <<read_employees>>\n   LOOP\n      FETCH c_employees INTO r_employee;\n      EXIT read_employees WHEN c_employees%NOTFOUND;\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP read_employees;\n\n   CLOSE c_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\nBEGIN\n   <<read_employees>>\n   FOR r_employee IN c_employees\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP read_employees;\nEND;\n/",
            "title": "G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4330/#g-4330-always-use-a-cursor-for-loop-to-process-the-complete-cursor-results-unless-you-are-using-bulk-operations",
            "text": "Minor  Maintainability",
            "title": "G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4330/#reason",
            "text": "It is easier for the reader to see, that the complete data set is processed. Using SQL to define the data to be processed is easier to maintain and typically faster than using conditional processing within the loop.  Since an  EXIT  statement is similar to a  GOTO  statement, \nit should be avoided, whenever possible.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4330/#example-bad",
            "text": "DECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\n   r_employee c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n\n   <<read_employees>>\n   LOOP\n      FETCH c_employees INTO r_employee;\n      EXIT read_employees WHEN c_employees%NOTFOUND;\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP read_employees;\n\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4330/#example-good",
            "text": "DECLARE\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\nBEGIN\n   <<read_employees>>\n   FOR r_employee IN c_employees\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n   END LOOP read_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4340/",
            "text": "G-4340: Always use a NUMERIC FOR loop to process a dense array.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt is easier for the reader to see, that the complete array is processed.\n\n\nSince an \nEXIT\n statement is similar to a \nGOTO\n statement, \nit should be avoided, whenever possible.\n\n\nExample (bad)\n\n\nDECLARE\n   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_himuro     CONSTANT INTEGER := 118;\n   co_livingston CONSTANT INTEGER := 177;\n   co_min_value  CONSTANT SIMPLE_INTEGER := 1;\n   co_increment  CONSTANT SIMPLE_INTEGER := 1;\n   i PLS_INTEGER;\nBEGIN\n   t_employees := t_employee_type(co_himuro, co_livingston);\n   i           := co_min_value;\n\n   <<process_employees>>\n   LOOP\n      EXIT process_employees WHEN i > t_employees.COUNT();\n      sys.dbms_output.put_line(t_employees(i));\n      i := i + co_increment;\n   END LOOP process_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_himuro     CONSTANT INTEGER := 118;\n   co_livingston CONSTANT INTEGER := 177;\nBEGIN\n   t_employees := t_employee_type(co_himuro, co_livingston);\n\n   <<process_employees>>\n   FOR i IN 1..t_employees.COUNT()\n   LOOP\n     sys.dbms_output.put_line(t_employees(i));\n   END LOOP process_employees;\nEND;\n/",
            "title": "G-4340: Always use a NUMERIC FOR loop to process a dense array."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4340/#g-4340-always-use-a-numeric-for-loop-to-process-a-dense-array",
            "text": "Minor  Maintainability",
            "title": "G-4340: Always use a NUMERIC FOR loop to process a dense array."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4340/#reason",
            "text": "It is easier for the reader to see, that the complete array is processed.  Since an  EXIT  statement is similar to a  GOTO  statement, \nit should be avoided, whenever possible.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4340/#example-bad",
            "text": "DECLARE\n   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_himuro     CONSTANT INTEGER := 118;\n   co_livingston CONSTANT INTEGER := 177;\n   co_min_value  CONSTANT SIMPLE_INTEGER := 1;\n   co_increment  CONSTANT SIMPLE_INTEGER := 1;\n   i PLS_INTEGER;\nBEGIN\n   t_employees := t_employee_type(co_himuro, co_livingston);\n   i           := co_min_value;\n\n   <<process_employees>>\n   LOOP\n      EXIT process_employees WHEN i > t_employees.COUNT();\n      sys.dbms_output.put_line(t_employees(i));\n      i := i + co_increment;\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4340/#example-good",
            "text": "DECLARE\n   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_himuro     CONSTANT INTEGER := 118;\n   co_livingston CONSTANT INTEGER := 177;\nBEGIN\n   t_employees := t_employee_type(co_himuro, co_livingston);\n\n   <<process_employees>>\n   FOR i IN 1..t_employees.COUNT()\n   LOOP\n     sys.dbms_output.put_line(t_employees(i));\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4350/",
            "text": "G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nDoing so will not raise a \nVALUE_ERROR\n if the array you are looping through is empty. If you want to use \nFIRST()..LAST()\n you need to check the array for emptiness beforehand to avoid the raise of \nVALUE_ERROR\n.\n\n\nExample (bad)\n\n\nDECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type := t_employee_type();\nBEGIN\n   <<process_employees>>\n   FOR i IN t_employees.FIRST()..t_employees.LAST()\n   LOOP\n      sys.dbms_output.put_line(t_employees(i)); -- some processing\n   END LOOP process_employees;\nEND;\n/\n\n\n\n\nExample (better)\n\n\nRaise an unitialized collection error if \nt_employees\n is not initialized.\n\n\nDECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type := t_employee_type();\nBEGIN\n   <<process_employees>>\n   FOR i IN 1..t_employees.COUNT()\n   LOOP\n      sys.dbms_output.put_line(t_employees(i)); -- some processing\n   END LOOP process_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nRaises neither an error nor checking whether the array is empty. \nt_employees.COUNT()\n always returns a \nNUMBER\n (unless the array is not initialized). If the array is empty \nCOUNT()\n returns 0 and therefore the loop will not be entered.\n\n\nDECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type := t_employee_type();\nBEGIN\n   IF t_employees IS NOT NULL THEN\n      <<process_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i)); -- some processing\n      END LOOP process_employees;\n   END IF;\nEND;\n/",
            "title": "G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4350/#g-4350-always-use-1-as-lower-and-count-as-upper-bound-when-looping-through-a-dense-array",
            "text": "Major  Reliability",
            "title": "G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4350/#reason",
            "text": "Doing so will not raise a  VALUE_ERROR  if the array you are looping through is empty. If you want to use  FIRST()..LAST()  you need to check the array for emptiness beforehand to avoid the raise of  VALUE_ERROR .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4350/#example-bad",
            "text": "DECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type := t_employee_type();\nBEGIN\n   <<process_employees>>\n   FOR i IN t_employees.FIRST()..t_employees.LAST()\n   LOOP\n      sys.dbms_output.put_line(t_employees(i)); -- some processing\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4350/#example-better",
            "text": "Raise an unitialized collection error if  t_employees  is not initialized.  DECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type := t_employee_type();\nBEGIN\n   <<process_employees>>\n   FOR i IN 1..t_employees.COUNT()\n   LOOP\n      sys.dbms_output.put_line(t_employees(i)); -- some processing\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (better)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4350/#example-good",
            "text": "Raises neither an error nor checking whether the array is empty.  t_employees.COUNT()  always returns a  NUMBER  (unless the array is not initialized). If the array is empty  COUNT()  returns 0 and therefore the loop will not be entered.  DECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type := t_employee_type();\nBEGIN\n   IF t_employees IS NOT NULL THEN\n      <<process_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i)); -- some processing\n      END LOOP process_employees;\n   END IF;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4360/",
            "text": "G-4360: Always use a WHILE loop to process a loose array.\n\n\n\n\nMinor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nWhen a loose array is processed using a NUMERIC \nFOR LOOP\n we have to check with all iterations whether the element exist to avoid a \nNO_DATA_FOUND\n exception. In addition, the number of iterations is not driven by the number of elements in the array but by the number of the lowest/highest element. The more gaps we have, the more superfluous iterations will be done.\n\n\nExample (bad)\n\n\nDECLARE -- raises no_data_found when processing 2nd record\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_rogers      CONSTANT INTEGER := 134;\n   co_matos       CONSTANT INTEGER := 143;\n   co_mcewen      CONSTANT INTEGER := 158;\n   co_index_matos CONSTANT INTEGER := 2;\nBEGIN\n   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);\n   t_employees.DELETE(co_index_matos);\n\n   IF t_employees IS NOT NULL THEN\n      <<process_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i));\n      END LOOP process_employees;\n   END IF;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_rogers      CONSTANT INTEGER := 134;\n   co_matos       CONSTANT INTEGER := 143;\n   co_mcewen      CONSTANT INTEGER := 158;\n   co_index_matos CONSTANT INTEGER := 2;\n   l_index        PLS_INTEGER;\nBEGIN\n   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);\n   t_employees.DELETE(co_index_matos);\n\n   l_index := t_employees.FIRST();\n\n   <<process_employees>>\n   WHILE l_index IS NOT NULL\n   LOOP\n      sys.dbms_output.put_line(t_employees(l_index));\n      l_index := t_employees.NEXT(l_index);\n   END LOOP process_employees;\nEND;\n/",
            "title": "G-4360: Always use a WHILE loop to process a loose array."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4360/#g-4360-always-use-a-while-loop-to-process-a-loose-array",
            "text": "Minor  Efficiency",
            "title": "G-4360: Always use a WHILE loop to process a loose array."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4360/#reason",
            "text": "When a loose array is processed using a NUMERIC  FOR LOOP  we have to check with all iterations whether the element exist to avoid a  NO_DATA_FOUND  exception. In addition, the number of iterations is not driven by the number of elements in the array but by the number of the lowest/highest element. The more gaps we have, the more superfluous iterations will be done.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4360/#example-bad",
            "text": "DECLARE -- raises no_data_found when processing 2nd record\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_rogers      CONSTANT INTEGER := 134;\n   co_matos       CONSTANT INTEGER := 143;\n   co_mcewen      CONSTANT INTEGER := 158;\n   co_index_matos CONSTANT INTEGER := 2;\nBEGIN\n   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);\n   t_employees.DELETE(co_index_matos);\n\n   IF t_employees IS NOT NULL THEN\n      <<process_employees>>\n      FOR i IN 1..t_employees.COUNT()\n      LOOP\n         sys.dbms_output.put_line(t_employees(i));\n      END LOOP process_employees;\n   END IF;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4360/#example-good",
            "text": "DECLARE\n   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;\n   t_employees t_employee_type;\n   co_rogers      CONSTANT INTEGER := 134;\n   co_matos       CONSTANT INTEGER := 143;\n   co_mcewen      CONSTANT INTEGER := 158;\n   co_index_matos CONSTANT INTEGER := 2;\n   l_index        PLS_INTEGER;\nBEGIN\n   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);\n   t_employees.DELETE(co_index_matos);\n\n   l_index := t_employees.FIRST();\n\n   <<process_employees>>\n   WHILE l_index IS NOT NULL\n   LOOP\n      sys.dbms_output.put_line(t_employees(l_index));\n      l_index := t_employees.NEXT(l_index);\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4370/",
            "text": "G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop.\n\n\n\n\nMajor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nA numeric for loop as well as a while loop and a cursor for loop have defined loop boundaries. If you are not able to exit your loop using those loop boundaries, then a basic loop is the right loop to choose.\n\n\nExample (bad)\n\n\nDECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n      EXIT while_loop WHEN i > co_max_value;\n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      NULL;\n      EXIT for_loop WHEN i = co_max_value;\n   END LOOP for_loop;\n\n   <<process_employees>>\n   FOR r_employee IN (SELECT last_name\n                        FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n      NULL; -- some processing\n      EXIT process_employees;\n   END LOOP process_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\n\n   <<process_employees>>\n   FOR r_employee IN (SELECT last_name\n                        FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name); -- some processing\n   END LOOP process_employees;\nEND;\n/",
            "title": "G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4370/#g-4370-avoid-using-exit-to-stop-loop-processing-unless-you-are-in-a-basic-loop",
            "text": "Major  Maintainability",
            "title": "G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4370/#reason",
            "text": "A numeric for loop as well as a while loop and a cursor for loop have defined loop boundaries. If you are not able to exit your loop using those loop boundaries, then a basic loop is the right loop to choose.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4370/#example-bad",
            "text": "DECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n      EXIT while_loop WHEN i > co_max_value;\n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      NULL;\n      EXIT for_loop WHEN i = co_max_value;\n   END LOOP for_loop;\n\n   <<process_employees>>\n   FOR r_employee IN (SELECT last_name\n                        FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name);\n      NULL; -- some processing\n      EXIT process_employees;\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4370/#example-good",
            "text": "DECLARE\n   i INTEGER;\n   co_min_value CONSTANT SIMPLE_INTEGER := 1;\n   co_max_value CONSTANT SIMPLE_INTEGER := 10;\n   co_increment CONSTANT SIMPLE_INTEGER := 1;\nBEGIN\n   i := co_min_value;\n   <<while_loop>>\n   WHILE (i <= co_max_value) \n   LOOP \n      i := i + co_increment; \n   END LOOP while_loop;\n\n   <<basic_loop>>\n   LOOP \n      EXIT basic_loop;\n   END LOOP basic_loop;\n\n   <<for_loop>>\n   FOR i IN co_min_value..co_max_value\n   LOOP \n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\n\n   <<process_employees>>\n   FOR r_employee IN (SELECT last_name\n                        FROM employees)\n   LOOP\n      sys.dbms_output.put_line(r_employee.last_name); -- some processing\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4375/",
            "text": "G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIf you need to use an \nEXIT\n statement use its full semantic to make the code easier to understand and maintain. There is simply no need for an additional IF statement.\n\n\nExample (bad)\n\n\nDECLARE\n   co_first_year CONSTANT PLS_INTEGER := 1900;\nBEGIN\n   <<process_employees>>\n   LOOP\n      my_package.some_processing();\n\n      IF EXTRACT(year FROM SYSDATE) > co_first_year THEN\n         EXIT process_employees;\n      END IF;\n\n      my_package.some_further_processing();\n   END LOOP process_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_first_year CONSTANT PLS_INTEGER := 1900;\nBEGIN\n   <<process_employees>>\n   LOOP\n      my_package.some_processing();\n\n      EXIT process_employees WHEN EXTRACT(YEAR FROM SYSDATE) > co_first_year;\n\n      my_package.some_further_processing();\n   END LOOP process_employees;\nEND;\n/",
            "title": "G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4375/#g-4375-always-use-exit-when-instead-of-an-if-statement-to-exit-from-a-loop",
            "text": "Minor  Maintainability",
            "title": "G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4375/#reason",
            "text": "If you need to use an  EXIT  statement use its full semantic to make the code easier to understand and maintain. There is simply no need for an additional IF statement.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4375/#example-bad",
            "text": "DECLARE\n   co_first_year CONSTANT PLS_INTEGER := 1900;\nBEGIN\n   <<process_employees>>\n   LOOP\n      my_package.some_processing();\n\n      IF EXTRACT(year FROM SYSDATE) > co_first_year THEN\n         EXIT process_employees;\n      END IF;\n\n      my_package.some_further_processing();\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4375/#example-good",
            "text": "DECLARE\n   co_first_year CONSTANT PLS_INTEGER := 1900;\nBEGIN\n   <<process_employees>>\n   LOOP\n      my_package.some_processing();\n\n      EXIT process_employees WHEN EXTRACT(YEAR FROM SYSDATE) > co_first_year;\n\n      my_package.some_further_processing();\n   END LOOP process_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4380/",
            "text": "G-4380    Try to label your EXIT WHEN statements.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt's a good alternative for comments, especially for nested loops to name the loop to exit.\n\n\nExample (bad)\n\n\nDECLARE\n   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;\n   co_increment  CONSTANT SIMPLE_INTEGER           := 1;\n   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;\n   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';\n   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';\n   l_outerlp PLS_INTEGER;\n   l_innerlp PLS_INTEGER;\nBEGIN\n   l_outerlp := co_init_loop;\n   <<outerloop>>\n   LOOP\n      l_innerlp := co_init_loop;\n      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;\n      <<innerloop>>\n      LOOP\n         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;\n         sys.dbms_output.put_line(co_outer_text || l_outerlp ||\n                                  co_inner_text || l_innerlp);\n\n         EXIT WHEN l_innerlp = co_exit_value;\n      END LOOP innerloop;\n\n      EXIT WHEN l_innerlp = co_exit_value;\n   END LOOP outerloop;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;\n   co_increment  CONSTANT SIMPLE_INTEGER           := 1;\n   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;\n   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';\n   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';\n   l_outerlp PLS_INTEGER;\n   l_innerlp PLS_INTEGER;\nBEGIN\n   l_outerlp := co_init_loop;\n   <<outerloop>>\n   LOOP\n      l_innerlp := co_init_loop;\n      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;\n      <<innerloop>>\n      LOOP\n         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;\n         sys.dbms_output.put_line(co_outer_text || l_outerlp ||\n                                  co_inner_text || l_innerlp);\n\n         EXIT outerloop WHEN l_innerlp = co_exit_value;\n      END LOOP innerloop;\n   END LOOP outerloop;\nEND;\n/",
            "title": "G-4380\tTry to label your EXIT WHEN statements."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4380/#g-4380-try-to-label-your-exit-when-statements",
            "text": "Minor  Maintainability",
            "title": "G-4380    Try to label your EXIT WHEN statements."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4380/#reason",
            "text": "It's a good alternative for comments, especially for nested loops to name the loop to exit.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4380/#example-bad",
            "text": "DECLARE\n   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;\n   co_increment  CONSTANT SIMPLE_INTEGER           := 1;\n   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;\n   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';\n   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';\n   l_outerlp PLS_INTEGER;\n   l_innerlp PLS_INTEGER;\nBEGIN\n   l_outerlp := co_init_loop;\n   <<outerloop>>\n   LOOP\n      l_innerlp := co_init_loop;\n      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;\n      <<innerloop>>\n      LOOP\n         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;\n         sys.dbms_output.put_line(co_outer_text || l_outerlp ||\n                                  co_inner_text || l_innerlp);\n\n         EXIT WHEN l_innerlp = co_exit_value;\n      END LOOP innerloop;\n\n      EXIT WHEN l_innerlp = co_exit_value;\n   END LOOP outerloop;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4380/#example-good",
            "text": "DECLARE\n   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;\n   co_increment  CONSTANT SIMPLE_INTEGER           := 1;\n   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;\n   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';\n   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';\n   l_outerlp PLS_INTEGER;\n   l_innerlp PLS_INTEGER;\nBEGIN\n   l_outerlp := co_init_loop;\n   <<outerloop>>\n   LOOP\n      l_innerlp := co_init_loop;\n      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;\n      <<innerloop>>\n      LOOP\n         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;\n         sys.dbms_output.put_line(co_outer_text || l_outerlp ||\n                                  co_inner_text || l_innerlp);\n\n         EXIT outerloop WHEN l_innerlp = co_exit_value;\n      END LOOP innerloop;\n   END LOOP outerloop;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4385/",
            "text": "G-4385: Never use a cursor for loop to check whether a cursor returns data.\n\n\n\n\nMajor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nYou might process more data than required, which leads to bad performance.\n\n\nExample (bad)\n\n\nDECLARE\n   l_employee_found BOOLEAN := FALSE;\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\nBEGIN\n   <<check_employees>>\n   FOR r_employee IN c_employees\n   LOOP\n      l_employee_found := TRUE;\n   END LOOP check_employees;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_employee_found BOOLEAN := FALSE;\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\n   r_employee c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n   FETCH c_employees INTO r_employee;\n   l_employee_found := c_employees%FOUND;\n   CLOSE c_employees;\nEND;\n/",
            "title": "G-4385: Never use a cursor for loop to check whether a cursor returns data."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4385/#g-4385-never-use-a-cursor-for-loop-to-check-whether-a-cursor-returns-data",
            "text": "Major  Efficiency",
            "title": "G-4385: Never use a cursor for loop to check whether a cursor returns data."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4385/#reason",
            "text": "You might process more data than required, which leads to bad performance.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4385/#example-bad",
            "text": "DECLARE\n   l_employee_found BOOLEAN := FALSE;\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\nBEGIN\n   <<check_employees>>\n   FOR r_employee IN c_employees\n   LOOP\n      l_employee_found := TRUE;\n   END LOOP check_employees;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4385/#example-good",
            "text": "DECLARE\n   l_employee_found BOOLEAN := FALSE;\n   CURSOR c_employees IS\n      SELECT employee_id, last_name\n        FROM employees;\n   r_employee c_employees%ROWTYPE;\nBEGIN\n   OPEN c_employees;\n   FETCH c_employees INTO r_employee;\n   l_employee_found := c_employees%FOUND;\n   CLOSE c_employees;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4390/",
            "text": "G-4390: Avoid use of unreferenced FOR loop indexes.\n\n\n\n\nMajor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nIf the loop index is used for anything but traffic control inside the loop, this is one of the indicators that a numeric FOR loop is being used incorrectly. The actual body of executable statements completely ignores the loop index. When that is the case, there is a good chance that you do not need the loop at all.\n\n\nExample (bad)\n\n\nDECLARE\n   l_row   PLS_INTEGER;\n   l_value PLS_INTEGER;\n   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;\n   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;\n   co_row_incr    CONSTANT SIMPLE_INTEGER           := 1;\n   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;\n   co_delimiter   CONSTANT types_up.short_text_type := ' ';\n   co_first_value CONSTANT SIMPLE_INTEGER           := 100;\nBEGIN\n   l_row := co_lower_bound;\n   l_value := co_first_value;\n   <<for_loop>>\n   FOR i IN co_lower_bound .. co_upper_bound\n   LOOP\n      sys.dbms_output.put_line(l_row || co_delimiter || l_value);\n      l_row   := l_row + co_row_incr;\n      l_value := l_value + co_value_incr;\n   END LOOP for_loop;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;\n   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;\n   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;\n   co_delimiter   CONSTANT types_up.short_text_type := ' ';\n   co_first_value CONSTANT SIMPLE_INTEGER           := 100;\nBEGIN\n   <<for_loop>>\n   FOR i IN co_lower_bound .. co_upper_bound\n   LOOP\n      sys.dbms_output.put_line(i || co_delimiter ||\n                               to_char(co_first_value + i * co_value_incr));\n   END LOOP for_loop;\nEND;\n/",
            "title": "G-4390: Avoid use of unreferenced FOR loop indexes."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4390/#g-4390-avoid-use-of-unreferenced-for-loop-indexes",
            "text": "Major  Efficiency",
            "title": "G-4390: Avoid use of unreferenced FOR loop indexes."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4390/#reason",
            "text": "If the loop index is used for anything but traffic control inside the loop, this is one of the indicators that a numeric FOR loop is being used incorrectly. The actual body of executable statements completely ignores the loop index. When that is the case, there is a good chance that you do not need the loop at all.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4390/#example-bad",
            "text": "DECLARE\n   l_row   PLS_INTEGER;\n   l_value PLS_INTEGER;\n   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;\n   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;\n   co_row_incr    CONSTANT SIMPLE_INTEGER           := 1;\n   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;\n   co_delimiter   CONSTANT types_up.short_text_type := ' ';\n   co_first_value CONSTANT SIMPLE_INTEGER           := 100;\nBEGIN\n   l_row := co_lower_bound;\n   l_value := co_first_value;\n   <<for_loop>>\n   FOR i IN co_lower_bound .. co_upper_bound\n   LOOP\n      sys.dbms_output.put_line(l_row || co_delimiter || l_value);\n      l_row   := l_row + co_row_incr;\n      l_value := l_value + co_value_incr;\n   END LOOP for_loop;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4390/#example-good",
            "text": "DECLARE\n   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;\n   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;\n   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;\n   co_delimiter   CONSTANT types_up.short_text_type := ' ';\n   co_first_value CONSTANT SIMPLE_INTEGER           := 100;\nBEGIN\n   <<for_loop>>\n   FOR i IN co_lower_bound .. co_upper_bound\n   LOOP\n      sys.dbms_output.put_line(i || co_delimiter ||\n                               to_char(co_first_value + i * co_value_incr));\n   END LOOP for_loop;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4395/",
            "text": "G-4395: Avoid hard-coded upper or lower bound values with FOR loops.\n\n\n\n\nMinor\n\n\nChangeability, Maintainability\n\n\n\n\nReason\n\n\nYour \nLOOP\n statement uses a hard-coded value for either its upper or lower bounds. This creates a \"weak link\" in your program because it assumes that this value will never change. A better practice is to create a named constant (or function) and reference this named element instead of the hard-coded value.\n\n\nExample (bad)\n\n\nBEGIN\n   <<for_loop>>\n   FOR i IN 1..5\n   LOOP\n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_lower_bound CONSTANT SIMPLE_INTEGER := 1;\n   co_upper_bound CONSTANT SIMPLE_INTEGER := 5;\nBEGIN\n   <<for_loop>>\n   FOR i IN co_lower_bound..co_upper_bound\n   LOOP\n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\nEND;\n/",
            "title": "G-4395: Avoid hard-coded upper or lower bound values with FOR loops."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4395/#g-4395-avoid-hard-coded-upper-or-lower-bound-values-with-for-loops",
            "text": "Minor  Changeability, Maintainability",
            "title": "G-4395: Avoid hard-coded upper or lower bound values with FOR loops."
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4395/#reason",
            "text": "Your  LOOP  statement uses a hard-coded value for either its upper or lower bounds. This creates a \"weak link\" in your program because it assumes that this value will never change. A better practice is to create a named constant (or function) and reference this named element instead of the hard-coded value.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4395/#example-bad",
            "text": "BEGIN\n   <<for_loop>>\n   FOR i IN 1..5\n   LOOP\n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/4-control-structures/3-flow-control/g-4395/#example-good",
            "text": "DECLARE\n   co_lower_bound CONSTANT SIMPLE_INTEGER := 1;\n   co_upper_bound CONSTANT SIMPLE_INTEGER := 5;\nBEGIN\n   <<for_loop>>\n   FOR i IN co_lower_bound..co_upper_bound\n   LOOP\n      sys.dbms_output.put_line(i);\n   END LOOP for_loop;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5010/",
            "text": "G-5010: Try to use a error/logging framework for your application.\n\n\n\n\nCritical\n\n\nReliability, Reusability, Testability\n\n\n\n\nReason\n\n\nHaving a framework to raise/handle/log your errors allows you to easily avoid duplicate application error numbers and having different error messages for the same type of error.\n\n\nThis kind of framework should include\n\n\n\n\nLogging (different channels like table, mail, file, etc. if needed)\n\n\nError Raising\n\n\nMultilanguage support if needed\n\n\nTranslate ORACLE error messages to a user friendly error text\n\n\nError repository\n\n\n\n\nExample (bad)\n\n\nBEGIN\n   sys.dbms_output.put_line('START');\n   -- some processing\n   sys.dbms_output.put_line('END');\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE \n  -- see https://github.com/OraOpenSource/Logger\n  l_scope logger_logs.scope%type := 'DEMO';\nBEGIN\n  logger.log('START', l_scope);\n  -- some processing\n  logger.log('END', l_scope);\nEND;\n/",
            "title": "G-5010: Try to use a error/logging framework for your application."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5010/#g-5010-try-to-use-a-errorlogging-framework-for-your-application",
            "text": "Critical  Reliability, Reusability, Testability",
            "title": "G-5010: Try to use a error/logging framework for your application."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5010/#reason",
            "text": "Having a framework to raise/handle/log your errors allows you to easily avoid duplicate application error numbers and having different error messages for the same type of error.  This kind of framework should include   Logging (different channels like table, mail, file, etc. if needed)  Error Raising  Multilanguage support if needed  Translate ORACLE error messages to a user friendly error text  Error repository",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5010/#example-bad",
            "text": "BEGIN\n   sys.dbms_output.put_line('START');\n   -- some processing\n   sys.dbms_output.put_line('END');\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5010/#example-good",
            "text": "DECLARE \n  -- see https://github.com/OraOpenSource/Logger\n  l_scope logger_logs.scope%type := 'DEMO';\nBEGIN\n  logger.log('START', l_scope);\n  -- some processing\n  logger.log('END', l_scope);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5020/",
            "text": "G-5020: Never handle unnamed exceptions using the error number.\n\n\n\n\nCritical\n\n\nMaintainability\n\n\n\n\nReason\n\n\nWhen literals are used for error numbers the reader needs the error message manual to unterstand what is going on. Commenting the code or using constants is an option, \nbut it is better to use named exceptions instead, because it ensures a certain level of consistency which makes maintenance easier.\n\n\nExample (bad)\n\n\nDECLARE\n   co_no_data_found CONSTANT INTEGER := -1;\nBEGIN\n   my_package.some_processing(); -- some code which raises an exception\nEXCEPTION\n   WHEN TOO_MANY_ROWS THEN\n      my_package.some_further_processing();\n   WHEN OTHERS THEN\n      IF SQLCODE = co_no_data_found THEN\n         NULL;\n      END IF;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN\n   my_package.some_processing(); -- some code which raises an exception\nEXCEPTION\n   WHEN TOO_MANY_ROWS THEN\n      my_package.some_further_processing();\n   WHEN NO_DATA_FOUND THEN\n      NULL; -- handle no_data_found\nEND;\n/",
            "title": "G-5020: Never handle unnamed exceptions using the error number."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5020/#g-5020-never-handle-unnamed-exceptions-using-the-error-number",
            "text": "Critical  Maintainability",
            "title": "G-5020: Never handle unnamed exceptions using the error number."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5020/#reason",
            "text": "When literals are used for error numbers the reader needs the error message manual to unterstand what is going on. Commenting the code or using constants is an option, \nbut it is better to use named exceptions instead, because it ensures a certain level of consistency which makes maintenance easier.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5020/#example-bad",
            "text": "DECLARE\n   co_no_data_found CONSTANT INTEGER := -1;\nBEGIN\n   my_package.some_processing(); -- some code which raises an exception\nEXCEPTION\n   WHEN TOO_MANY_ROWS THEN\n      my_package.some_further_processing();\n   WHEN OTHERS THEN\n      IF SQLCODE = co_no_data_found THEN\n         NULL;\n      END IF;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5020/#example-good",
            "text": "BEGIN\n   my_package.some_processing(); -- some code which raises an exception\nEXCEPTION\n   WHEN TOO_MANY_ROWS THEN\n      my_package.some_further_processing();\n   WHEN NO_DATA_FOUND THEN\n      NULL; -- handle no_data_found\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5030/",
            "text": "G-5030: Never assign predefined exception names to user defined exceptions.\n\n\n\n\nBlocker\n\n\nReliability, Testability\n\n\n\n\nReason\n\n\nThis is error-prone because your local declaration overrides the global declaration. While it is technically possible to use the same names, it causes confusion for others needing to read and maintain this code. Additionally, you will need to be very careful to use the prefix \nSTANDARD\n in front of any reference that needs to use Oracle\u2019s default exception behavior.\n\n\nExample (bad)\n\n\nUsing the code below, we are not able to handle the no_data_found exception raised by the \nSELECT\n statement as we have overwritten that exception handler. In addition, our exception handler has not the exception number assigned, which is raise when the SELECT statement does not find any rows.\n\n\nDECLARE\n   l_dummy dual.dummy%TYPE;\n   no_data_found    EXCEPTION;\n   co_rownum        CONSTANT SIMPLE_INTEGER           := 0;\n   co_no_data_found CONSTANT types_up.short_text_type := 'no_data_found';\nBEGIN\n   SELECT dummy\n     INTO l_dummy\n     FROM dual\n    WHERE ROWNUM = co_rownum;\n\n   IF l_dummy IS NULL THEN \n      RAISE no_data_found;\n   END IF;\nEXCEPTION\n   WHEN no_data_found THEN\n      sys.dbms_output.put_line(co_no_data_found);\nEND;\n/\n\nError report -\nORA-01403: no data found\nORA-06512: at line 5\n01403. 00000 -  \"no data found\"\n*Cause:    No data was found from the objects.\n*Action:   There was no data from the objects which may be due to end of fetch.\n\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_dummy dual.dummy%TYPE;\n   empty_value      EXCEPTION;\n   co_rownum        CONSTANT simple_integer           := 0;\n   co_empty_value   CONSTANT types_up.short_text_type := 'empty_value';\n   co_no_data_found CONSTANT types_up.short_text_type := 'no_data_found';\nBEGIN\n   SELECT dummy\n     INTO l_dummy\n     FROM dual\n    WHERE rownum = co_rownum;\n\n   IF l_dummy IS NULL THEN\n      RAISE empty_value;\n   END IF;\nEXCEPTION\n   WHEN empty_value THEN\n      sys.dbms_output.put_line(co_empty_value);\n   WHEN no_data_found THEN\n      sys.dbms_output.put_line(co_no_data_found);\nEND;\n/",
            "title": "G-5030: Never assign predefined exception names to user defined exceptions."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5030/#g-5030-never-assign-predefined-exception-names-to-user-defined-exceptions",
            "text": "Blocker  Reliability, Testability",
            "title": "G-5030: Never assign predefined exception names to user defined exceptions."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5030/#reason",
            "text": "This is error-prone because your local declaration overrides the global declaration. While it is technically possible to use the same names, it causes confusion for others needing to read and maintain this code. Additionally, you will need to be very careful to use the prefix  STANDARD  in front of any reference that needs to use Oracle\u2019s default exception behavior.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5030/#example-bad",
            "text": "Using the code below, we are not able to handle the no_data_found exception raised by the  SELECT  statement as we have overwritten that exception handler. In addition, our exception handler has not the exception number assigned, which is raise when the SELECT statement does not find any rows.  DECLARE\n   l_dummy dual.dummy%TYPE;\n   no_data_found    EXCEPTION;\n   co_rownum        CONSTANT SIMPLE_INTEGER           := 0;\n   co_no_data_found CONSTANT types_up.short_text_type := 'no_data_found';\nBEGIN\n   SELECT dummy\n     INTO l_dummy\n     FROM dual\n    WHERE ROWNUM = co_rownum;\n\n   IF l_dummy IS NULL THEN \n      RAISE no_data_found;\n   END IF;\nEXCEPTION\n   WHEN no_data_found THEN\n      sys.dbms_output.put_line(co_no_data_found);\nEND;\n/\n\nError report -\nORA-01403: no data found\nORA-06512: at line 5\n01403. 00000 -  \"no data found\"\n*Cause:    No data was found from the objects.\n*Action:   There was no data from the objects which may be due to end of fetch.",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5030/#example-good",
            "text": "DECLARE\n   l_dummy dual.dummy%TYPE;\n   empty_value      EXCEPTION;\n   co_rownum        CONSTANT simple_integer           := 0;\n   co_empty_value   CONSTANT types_up.short_text_type := 'empty_value';\n   co_no_data_found CONSTANT types_up.short_text_type := 'no_data_found';\nBEGIN\n   SELECT dummy\n     INTO l_dummy\n     FROM dual\n    WHERE rownum = co_rownum;\n\n   IF l_dummy IS NULL THEN\n      RAISE empty_value;\n   END IF;\nEXCEPTION\n   WHEN empty_value THEN\n      sys.dbms_output.put_line(co_empty_value);\n   WHEN no_data_found THEN\n      sys.dbms_output.put_line(co_no_data_found);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5040/",
            "text": "G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nThere is not necessarily anything wrong with using \nWHEN OTHERS\n, but it can cause you to \"lose\" error information unless your handler code is relatively sophisticated. Generally, you should use \nWHEN OTHERS\n to grab any and every error only after you have thought about your executable section and decided that you are not able to trap any specific exceptions. If you know, on the other hand, that a certain exception might be raised, include a handler for that error. By declaring two different exception handlers, the code more clearly states what we expect to have happen and how we want to handle the errors. That makes it easier to maintain and enhance. We also avoid hard-coding error numbers in checks against \nSQLCODE\n.\n\n\nExample (bad)\n\n\nBEGIN\n   my_package.some_processing();\nEXCEPTION\n   WHEN OTHERS THEN\n      my_package.some_further_processing();\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN\n   my_package.some_processing();\nEXCEPTION\n   WHEN DUP_VAL_ON_INDEX THEN\n      my_package.some_further_processing();\nEND;\n/",
            "title": "G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5040/#g-5040-avoid-use-of-when-others-clause-in-an-exception-section-without-any-other-specific-handlers",
            "text": "Major  Reliability",
            "title": "G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5040/#reason",
            "text": "There is not necessarily anything wrong with using  WHEN OTHERS , but it can cause you to \"lose\" error information unless your handler code is relatively sophisticated. Generally, you should use  WHEN OTHERS  to grab any and every error only after you have thought about your executable section and decided that you are not able to trap any specific exceptions. If you know, on the other hand, that a certain exception might be raised, include a handler for that error. By declaring two different exception handlers, the code more clearly states what we expect to have happen and how we want to handle the errors. That makes it easier to maintain and enhance. We also avoid hard-coding error numbers in checks against  SQLCODE .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5040/#example-bad",
            "text": "BEGIN\n   my_package.some_processing();\nEXCEPTION\n   WHEN OTHERS THEN\n      my_package.some_further_processing();\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5040/#example-good",
            "text": "BEGIN\n   my_package.some_processing();\nEXCEPTION\n   WHEN DUP_VAL_ON_INDEX THEN\n      my_package.some_further_processing();\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5050/",
            "text": "G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded  20nnn error number or hard-coded message.\n\n\n\n\nMajor\n\n\nChangeability, Maintainability\n\n\n\n\nReason\n\n\nIf you are not very organized in the way you allocate, define and use the error numbers between  20999 and  20000 (those reserved by Oracle for its user community), it is very easy to end up with conflicting usages. You should assign these error numbers to named constants and consolidate all definitions within a single package. When you call \nRAISE_APPLICATION_ERROR\n, you should reference these named elements and error message text stored in a table. Use your own raise procedure in place of explicit calls to \nRAISE_APPLICATION_ERROR\n. If you are raising a \"system\" exception like \nNO_DATA_FOUND\n, you must use RAISE. However, when you want to raise an application-specific error, you use \nRAISE_APPLICATION_ERROR\n. If you use the latter, you then have to provide an error number and message. This leads to unnecessary and damaging hard-coded values. A more fail-safe approach is to provide a predefined raise procedure that automatically checks the error number and determines the correct way to raise the error. \n\n\nExample (bad)\n\n\nBEGIN\n   raise_application_error(-20501,'Invalid employee_id');\nEND;\n/\n\n\n\n\nExample (good)\n\n\nBEGIN\n   err_up.raise(in_error => err.co_invalid_employee_id);\nEND;\n/",
            "title": "G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded  20nnn error number or hard-coded message."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5050/#g-5050-avoid-use-of-the-raise_application_error-built-in-procedure-with-a-hard-coded-20nnn-error-number-or-hard-coded-message",
            "text": "Major  Changeability, Maintainability",
            "title": "G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded  20nnn error number or hard-coded message."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5050/#reason",
            "text": "If you are not very organized in the way you allocate, define and use the error numbers between  20999 and  20000 (those reserved by Oracle for its user community), it is very easy to end up with conflicting usages. You should assign these error numbers to named constants and consolidate all definitions within a single package. When you call  RAISE_APPLICATION_ERROR , you should reference these named elements and error message text stored in a table. Use your own raise procedure in place of explicit calls to  RAISE_APPLICATION_ERROR . If you are raising a \"system\" exception like  NO_DATA_FOUND , you must use RAISE. However, when you want to raise an application-specific error, you use  RAISE_APPLICATION_ERROR . If you use the latter, you then have to provide an error number and message. This leads to unnecessary and damaging hard-coded values. A more fail-safe approach is to provide a predefined raise procedure that automatically checks the error number and determines the correct way to raise the error.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5050/#example-bad",
            "text": "BEGIN\n   raise_application_error(-20501,'Invalid employee_id');\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5050/#example-good",
            "text": "BEGIN\n   err_up.raise(in_error => err.co_invalid_employee_id);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5060/",
            "text": "G-5060: Avoid unhandled exceptions.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nThis may be your intention, but you should review the code to confirm this behavior. \n\n\nIf you are raising an error in a program, then you are clearly predicting a situation in which that error will occur. You should consider including a handler in your code for predictable errors, allowing for a graceful and informative failure. After all, it is much more difficult for an enclosing block to be aware of the various errors you might raise and more importantly, what should be done in response to the error. \n\n\nThe form that this failure takes does not necessarily need to be an exception. When writing functions, you may well decide that in the case of certain exceptions, you will want to return a value such as NULL, rather than allow an exception to propagate out of the function. \n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_id IN departments.department_id%TYPE) \n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      SELECT department_name\n        INTO l_department_name\n        FROM departments\n       WHERE department_id = in_id;\n\n      RETURN l_department_name;   \n   END name_by_id;\nEND department_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_id IN departments.department_id%TYPE) \n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      SELECT department_name\n        INTO l_department_name\n        FROM departments\n       WHERE department_id = in_id;\n\n      RETURN l_department_name;  \n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN RETURN NULL;\n      WHEN TOO_MANY_ROWS THEN RAISE;\n   END name_by_id;\nEND department_api;\n/",
            "title": "G-5060: Avoid unhandled exceptions."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5060/#g-5060-avoid-unhandled-exceptions",
            "text": "Major  Reliability",
            "title": "G-5060: Avoid unhandled exceptions."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5060/#reason",
            "text": "This may be your intention, but you should review the code to confirm this behavior.   If you are raising an error in a program, then you are clearly predicting a situation in which that error will occur. You should consider including a handler in your code for predictable errors, allowing for a graceful and informative failure. After all, it is much more difficult for an enclosing block to be aware of the various errors you might raise and more importantly, what should be done in response to the error.   The form that this failure takes does not necessarily need to be an exception. When writing functions, you may well decide that in the case of certain exceptions, you will want to return a value such as NULL, rather than allow an exception to propagate out of the function.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5060/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_id IN departments.department_id%TYPE) \n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      SELECT department_name\n        INTO l_department_name\n        FROM departments\n       WHERE department_id = in_id;\n\n      RETURN l_department_name;   \n   END name_by_id;\nEND department_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5060/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_id IN departments.department_id%TYPE) \n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      SELECT department_name\n        INTO l_department_name\n        FROM departments\n       WHERE department_id = in_id;\n\n      RETURN l_department_name;  \n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN RETURN NULL;\n      WHEN TOO_MANY_ROWS THEN RAISE;\n   END name_by_id;\nEND department_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5070/",
            "text": "G-5070: Avoid using Oracle predefined exceptions.\n\n\n\n\nCritical\n\n\nReliability\n\n\n\n\nReason\n\n\nYou have raised an exception whose name was defined by Oracle. While it is possible that you have a good reason for \"using\" one of Oracle's predefined exceptions, you should make sure that you would not be better off declaring your own exception and raising that instead.\n\n\nIf you decide to change the exception you are using, you should apply the same consideration to your own exceptions. Specifically, do not \"re-use\" exceptions. You should define a separate exception for each error condition, rather than use the same exception for different circumstances. \n\n\nBeing as specific as possible with the errors raised will allow developers to check for, and handle, the different kinds of errors the code might produce.\n\n\nExample (bad)\n\n\nBEGIN\n   RAISE NO_DATA_FOUND;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   my_exception EXCEPTION;\nBEGIN\n   RAISE my_exception;\nEND;\n/",
            "title": "G-5070: Avoid using Oracle predefined exceptions."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5070/#g-5070-avoid-using-oracle-predefined-exceptions",
            "text": "Critical  Reliability",
            "title": "G-5070: Avoid using Oracle predefined exceptions."
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5070/#reason",
            "text": "You have raised an exception whose name was defined by Oracle. While it is possible that you have a good reason for \"using\" one of Oracle's predefined exceptions, you should make sure that you would not be better off declaring your own exception and raising that instead.  If you decide to change the exception you are using, you should apply the same consideration to your own exceptions. Specifically, do not \"re-use\" exceptions. You should define a separate exception for each error condition, rather than use the same exception for different circumstances.   Being as specific as possible with the errors raised will allow developers to check for, and handle, the different kinds of errors the code might produce.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5070/#example-bad",
            "text": "BEGIN\n   RAISE NO_DATA_FOUND;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/5-exception-handling/g-5070/#example-good",
            "text": "DECLARE\n   my_exception EXCEPTION;\nBEGIN\n   RAISE my_exception;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6010/",
            "text": "G-6010: Always use a character variable to execute dynamic SQL.\n\n\n\n\nMajor\n\n\nMaintainability, Testability\n\n\n\n\nReason\n\n\nHaving the executed statement in a variable makes it easier to debug your code (e.g. by logging the statement that failed).\n\n\nExample (bad)\n\n\nDECLARE\n   l_next_val employees.employee_id%TYPE;\nBEGIN\n   EXECUTE IMMEDIATE 'select employees_seq.nextval from dual' INTO l_next_val;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_next_val employees.employee_id%TYPE;\n   co_sql CONSTANT types_up.big_string_type := \n       'select employees_seq.nextval from dual';\nBEGIN\n   EXECUTE IMMEDIATE co_sql INTO l_next_val;\nEND;\n/",
            "title": "G-6010: Always use a character variable to execute dynamic SQL."
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6010/#g-6010-always-use-a-character-variable-to-execute-dynamic-sql",
            "text": "Major  Maintainability, Testability",
            "title": "G-6010: Always use a character variable to execute dynamic SQL."
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6010/#reason",
            "text": "Having the executed statement in a variable makes it easier to debug your code (e.g. by logging the statement that failed).",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6010/#example-bad",
            "text": "DECLARE\n   l_next_val employees.employee_id%TYPE;\nBEGIN\n   EXECUTE IMMEDIATE 'select employees_seq.nextval from dual' INTO l_next_val;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6010/#example-good",
            "text": "DECLARE\n   l_next_val employees.employee_id%TYPE;\n   co_sql CONSTANT types_up.big_string_type := \n       'select employees_seq.nextval from dual';\nBEGIN\n   EXECUTE IMMEDIATE co_sql INTO l_next_val;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6020/",
            "text": "G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nWhen a dynamic \nINSERT\n, \nUPDATE\n, or \nDELETE\n statement has a \nRETURNING\n clause, output bind arguments can go in the \nRETURNING INTO\n clause or in the USING clause.\n\n\nYou should use the \nRETURNING INTO\n clause for values returned from a DML operation. Reserve \nOUT\n and \nIN OUT\n bind variables for dynamic PL/SQL blocks that return values in PL/SQL variables.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE upd_salary (in_employee_id  IN     employees.employee_id%TYPE\n                        ,in_increase_pct IN     types_up.percentage\n                        ,out_new_salary     OUT employees.salary%TYPE)\n   IS\n      co_sql_stmt CONSTANT types_up.big_string_type := '\n           UPDATE employees SET salary = salary + (salary / 100 * :1) \n            WHERE employee_id = :2\n        RETURNING salary INTO :3';\n   BEGIN\n     EXECUTE IMMEDIATE co_sql_stmt\n           USING in_increase_pct, in_employee_id, OUT out_new_salary;\n   END upd_salary;\nEND employee_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE upd_salary (in_employee_id  IN     employees.employee_id%TYPE\n                        ,in_increase_pct IN     types_up.percentage\n                        ,out_new_salary     OUT employees.salary%TYPE)\n   IS\n      co_sql_stmt CONSTANT types_up.big_string_type := \n          'UPDATE employees SET salary = salary + (salary / 100 * :1) \n            WHERE employee_id = :2\n        RETURNING salary INTO :3';\n   BEGIN\n     EXECUTE IMMEDIATE co_sql_stmt\n           USING in_increase_pct, in_employee_id\n           RETURNING INTO out_new_salary;\n   END upd_salary;\nEND employee_api;\n/",
            "title": "G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause."
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6020/#g-6020-try-to-use-output-bind-arguments-in-the-returning-into-clause-of-dynamic-dml-statements-rather-than-the-using-clause",
            "text": "Minor  Maintainability",
            "title": "G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause."
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6020/#reason",
            "text": "When a dynamic  INSERT ,  UPDATE , or  DELETE  statement has a  RETURNING  clause, output bind arguments can go in the  RETURNING INTO  clause or in the USING clause.  You should use the  RETURNING INTO  clause for values returned from a DML operation. Reserve  OUT  and  IN OUT  bind variables for dynamic PL/SQL blocks that return values in PL/SQL variables.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6020/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE upd_salary (in_employee_id  IN     employees.employee_id%TYPE\n                        ,in_increase_pct IN     types_up.percentage\n                        ,out_new_salary     OUT employees.salary%TYPE)\n   IS\n      co_sql_stmt CONSTANT types_up.big_string_type := '\n           UPDATE employees SET salary = salary + (salary / 100 * :1) \n            WHERE employee_id = :2\n        RETURNING salary INTO :3';\n   BEGIN\n     EXECUTE IMMEDIATE co_sql_stmt\n           USING in_increase_pct, in_employee_id, OUT out_new_salary;\n   END upd_salary;\nEND employee_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/6-dynamic-sql/g-6020/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE upd_salary (in_employee_id  IN     employees.employee_id%TYPE\n                        ,in_increase_pct IN     types_up.percentage\n                        ,out_new_salary     OUT employees.salary%TYPE)\n   IS\n      co_sql_stmt CONSTANT types_up.big_string_type := \n          'UPDATE employees SET salary = salary + (salary / 100 * :1) \n            WHERE employee_id = :2\n        RETURNING salary INTO :3';\n   BEGIN\n     EXECUTE IMMEDIATE co_sql_stmt\n           USING in_increase_pct, in_employee_id\n           RETURNING INTO out_new_salary;\n   END upd_salary;\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7110/",
            "text": "G-7110: Try to use named notation when calling program units.\n\n\n\n\nMajor\n\n\nChangeability, Maintainability\n\n\n\n\nReason\n\n\nNamed notation makes sure that changes to the signature of the called program unit do not affect your call.\n\n\nThis is not needed for standard functions like (\nTO_CHAR\n, \nTO_DATE\n, \nNVL\n, \nROUND\n, etc.) but should be followed for any other stored object having more than one parameter.\n\n\nExample (bad)\n\n\nDECLARE\n   r_employee employees%rowtype;\n   co_id CONSTANT employees.employee_id%type := 107;\nBEGIN\n   employee_api.employee_by_id(r_employee, co_id);\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   r_employee employees%rowtype;\n   co_id CONSTANT employees.employee_id%type := 107;\nBEGIN\n   employee_api.employee_by_id(out_row => r_employee, in_employee_id => co_id);\nEND;\n/",
            "title": "G-7110: Try to use named notation when calling program units."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7110/#g-7110-try-to-use-named-notation-when-calling-program-units",
            "text": "Major  Changeability, Maintainability",
            "title": "G-7110: Try to use named notation when calling program units."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7110/#reason",
            "text": "Named notation makes sure that changes to the signature of the called program unit do not affect your call.  This is not needed for standard functions like ( TO_CHAR ,  TO_DATE ,  NVL ,  ROUND , etc.) but should be followed for any other stored object having more than one parameter.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7110/#example-bad",
            "text": "DECLARE\n   r_employee employees%rowtype;\n   co_id CONSTANT employees.employee_id%type := 107;\nBEGIN\n   employee_api.employee_by_id(r_employee, co_id);\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7110/#example-good",
            "text": "DECLARE\n   r_employee employees%rowtype;\n   co_id CONSTANT employees.employee_id%type := 107;\nBEGIN\n   employee_api.employee_by_id(out_row => r_employee, in_employee_id => co_id);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7120/",
            "text": "G-7120    Always add the name of the program unit to its end keyword.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nIt's a good alternative for comments to indicate the end of program units, especially if they are lengthy or nested.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api IS\n   FUNCTION employee_by_id (in_employee_id IN employees.employee_id%TYPE)\n      RETURN employees%rowtype IS\n      r_employee employees%rowtype;\n   BEGIN\n      SELECT *\n        INTO r_employee\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      RETURN r_employee;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         RAISE;\n   END;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api IS\n   FUNCTION employee_by_id (in_employee_id IN employees.employee_id%TYPE)\n      RETURN employees%rowtype IS\n      r_employee employees%rowtype;\n   BEGIN\n      SELECT *\n        INTO r_employee\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      RETURN r_employee;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         RAISE;\n   END employee_by_id;\nEND employee_api;\n/",
            "title": "G-7120\tAlways add the name of the program unit to its end keyword."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7120/#g-7120-always-add-the-name-of-the-program-unit-to-its-end-keyword",
            "text": "Minor  Maintainability",
            "title": "G-7120    Always add the name of the program unit to its end keyword."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7120/#reason",
            "text": "It's a good alternative for comments to indicate the end of program units, especially if they are lengthy or nested.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7120/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api IS\n   FUNCTION employee_by_id (in_employee_id IN employees.employee_id%TYPE)\n      RETURN employees%rowtype IS\n      r_employee employees%rowtype;\n   BEGIN\n      SELECT *\n        INTO r_employee\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      RETURN r_employee;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         RAISE;\n   END;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7120/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api IS\n   FUNCTION employee_by_id (in_employee_id IN employees.employee_id%TYPE)\n      RETURN employees%rowtype IS\n      r_employee employees%rowtype;\n   BEGIN\n      SELECT *\n        INTO r_employee\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      RETURN r_employee;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         RAISE;\n   END employee_by_id;\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7130/",
            "text": "G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit.\n\n\n\n\nMajor\n\n\nMaintainability, Reliability, Testability\n\n\n\n\nReason\n\n\nLocal procedures and functions offer an excellent way to avoid code redundancy and make your code more readable (and thus more maintainable). Your local program refers, however, an external data structure, i.e., a variable that is declared outside of the local program. Thus, it is acting as a global variable inside the program. \n\n\nThis external dependency is hidden, and may cause problems in the future. You should instead add a parameter to the parameter list of this program and pass the value through the list. This technique makes your program more reusable and avoids scoping problems, i.e. the program unit is less tied to particular variables in the program. In addition, unit encapsulation makes maintenance a lot easier and cheaper.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY EMPLOYEE_API IS\n   PROCEDURE calc_salary (in_employee_id IN employees.employee_id%TYPE) IS\n      r_emp employees%rowtype;\n\n      FUNCTION commission RETURN NUMBER IS\n         l_commission employees.salary%TYPE := 0;\n      BEGIN\n         IF r_emp.commission_pct IS NOT NULL\n         THEN\n            l_commission := r_emp.salary * r_emp.commission_pct;\n         END IF;\n\n         RETURN l_commission;\n      END commission;\n   BEGIN\n      SELECT *\n        INTO r_emp\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      SYS.DBMS_OUTPUT.PUT_LINE(r_emp.salary + commission());\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         NULL;\n   END calc_salary;\nEND employee_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY EMPLOYEE_API IS\n   PROCEDURE calc_salary (in_employee_id IN employees.employee_id%TYPE) IS\n      r_emp employees%rowtype;\n\n      FUNCTION commission (in_salary   IN employees.salary%TYPE\n                          ,in_comm_pct IN employees.commission_pct%TYPE)\n         RETURN NUMBER IS\n         l_commission employees.salary%TYPE := 0;\n      BEGIN\n         IF in_comm_pct IS NOT NULL THEN\n            l_commission := in_salary * in_comm_pct;\n         END IF;\n\n         RETURN l_commission;\n      END commission;\n   BEGIN\n      SELECT *\n        INTO r_emp\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      SYS.DBMS_OUTPUT.PUT_LINE(\n         r_emp.salary + commission(in_salary   => r_emp.salary\n                                  ,in_comm_pct => r_emp.commission_pct)\n      );\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         NULL;\n   END calc_salary;\nEND employee_api;\n/",
            "title": "G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7130/#g-7130-always-use-parameters-or-pull-in-definitions-rather-than-referencing-external-variables-in-a-local-program-unit",
            "text": "Major  Maintainability, Reliability, Testability",
            "title": "G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7130/#reason",
            "text": "Local procedures and functions offer an excellent way to avoid code redundancy and make your code more readable (and thus more maintainable). Your local program refers, however, an external data structure, i.e., a variable that is declared outside of the local program. Thus, it is acting as a global variable inside the program.   This external dependency is hidden, and may cause problems in the future. You should instead add a parameter to the parameter list of this program and pass the value through the list. This technique makes your program more reusable and avoids scoping problems, i.e. the program unit is less tied to particular variables in the program. In addition, unit encapsulation makes maintenance a lot easier and cheaper.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7130/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY EMPLOYEE_API IS\n   PROCEDURE calc_salary (in_employee_id IN employees.employee_id%TYPE) IS\n      r_emp employees%rowtype;\n\n      FUNCTION commission RETURN NUMBER IS\n         l_commission employees.salary%TYPE := 0;\n      BEGIN\n         IF r_emp.commission_pct IS NOT NULL\n         THEN\n            l_commission := r_emp.salary * r_emp.commission_pct;\n         END IF;\n\n         RETURN l_commission;\n      END commission;\n   BEGIN\n      SELECT *\n        INTO r_emp\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      SYS.DBMS_OUTPUT.PUT_LINE(r_emp.salary + commission());\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         NULL;\n   END calc_salary;\nEND employee_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7130/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY EMPLOYEE_API IS\n   PROCEDURE calc_salary (in_employee_id IN employees.employee_id%TYPE) IS\n      r_emp employees%rowtype;\n\n      FUNCTION commission (in_salary   IN employees.salary%TYPE\n                          ,in_comm_pct IN employees.commission_pct%TYPE)\n         RETURN NUMBER IS\n         l_commission employees.salary%TYPE := 0;\n      BEGIN\n         IF in_comm_pct IS NOT NULL THEN\n            l_commission := in_salary * in_comm_pct;\n         END IF;\n\n         RETURN l_commission;\n      END commission;\n   BEGIN\n      SELECT *\n        INTO r_emp\n        FROM employees\n       WHERE employee_id = in_employee_id;\n\n      SYS.DBMS_OUTPUT.PUT_LINE(\n         r_emp.salary + commission(in_salary   => r_emp.salary\n                                  ,in_comm_pct => r_emp.commission_pct)\n      );\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         NULL;\n      WHEN TOO_MANY_ROWS THEN\n         NULL;\n   END calc_salary;\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7140/",
            "text": "G-7140: Always ensure that locally defined procedures or functions are referenced.\n\n\n\n\nMajor\n\n\nMaintainability, Reliability\n\n\n\n\nReason\n\n\nThis can occur as the result of changes to code over time, but you should make sure that this situation does not reflect a problem. And you should remove the declaration to avoid maintenance errors in the future.    \n\n\nYou should go through your programs and remove any part of your code that is no longer used. This is a relatively straightforward process for variables and named constants. Simply execute searches for a variable's name in that variable's scope. If you find that the only place it appears is in its declaration, delete the declaration. \n\n\nThere is never a better time to review all the steps you took, and to understand the reasons you took them, then immediately upon completion of your program. If you wait, you will find it particularly difficult to remember those parts of the program that were needed at one point, but were rendered unnecessary in the end.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      FUNCTION my_func RETURN NUMBER IS\n         co_true CONSTANT INTEGER := 1;\n      BEGIN\n         RETURN co_true;\n      END my_func;\n   BEGIN\n       NULL;\n   END my_procedure;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      FUNCTION my_func RETURN NUMBER IS\n         co_true CONSTANT INTEGER := 1;\n      BEGIN\n         RETURN co_true;\n      END my_func;\n   BEGIN\n       sys.dbms_output.put_line(my_func());\n   END my_procedure;\nEND my_package;\n/",
            "title": "G-7140: Always ensure that locally defined procedures or functions are referenced."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7140/#g-7140-always-ensure-that-locally-defined-procedures-or-functions-are-referenced",
            "text": "Major  Maintainability, Reliability",
            "title": "G-7140: Always ensure that locally defined procedures or functions are referenced."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7140/#reason",
            "text": "This can occur as the result of changes to code over time, but you should make sure that this situation does not reflect a problem. And you should remove the declaration to avoid maintenance errors in the future.      You should go through your programs and remove any part of your code that is no longer used. This is a relatively straightforward process for variables and named constants. Simply execute searches for a variable's name in that variable's scope. If you find that the only place it appears is in its declaration, delete the declaration.   There is never a better time to review all the steps you took, and to understand the reasons you took them, then immediately upon completion of your program. If you wait, you will find it particularly difficult to remember those parts of the program that were needed at one point, but were rendered unnecessary in the end.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7140/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      FUNCTION my_func RETURN NUMBER IS\n         co_true CONSTANT INTEGER := 1;\n      BEGIN\n         RETURN co_true;\n      END my_func;\n   BEGIN\n       NULL;\n   END my_procedure;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7140/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      FUNCTION my_func RETURN NUMBER IS\n         co_true CONSTANT INTEGER := 1;\n      BEGIN\n         RETURN co_true;\n      END my_func;\n   BEGIN\n       sys.dbms_output.put_line(my_func());\n   END my_procedure;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7150/",
            "text": "G-7150: Try to remove unused parameters.\n\n\n\n\nMinor\n\n\nEfficiency, Maintainability\n\n\n\n\nReason\n\n\nYou should go through your programs and remove any partameter that is no longer used.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE\n                       ,in_manager_id    IN departments.manager_id%TYPE)\n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      <<find_department>>\n      BEGIN\n         SELECT department_name\n           INTO l_department_name\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION\n         WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN \n            l_department_name := NULL;\n      END find_department;\n\n      RETURN l_department_name;\n   END name_by_id;\nEND department_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)\n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      <<find_department>>\n      BEGIN\n         SELECT department_name\n           INTO l_department_name\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION\n         WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN \n            l_department_name := NULL;\n      END find_department;\n\n      RETURN l_department_name;\n   END name_by_id;\nEND department_api;\n/",
            "title": "G-7150: Try to remove unused parameters."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7150/#g-7150-try-to-remove-unused-parameters",
            "text": "Minor  Efficiency, Maintainability",
            "title": "G-7150: Try to remove unused parameters."
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7150/#reason",
            "text": "You should go through your programs and remove any partameter that is no longer used.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7150/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE\n                       ,in_manager_id    IN departments.manager_id%TYPE)\n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      <<find_department>>\n      BEGIN\n         SELECT department_name\n           INTO l_department_name\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION\n         WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN \n            l_department_name := NULL;\n      END find_department;\n\n      RETURN l_department_name;\n   END name_by_id;\nEND department_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/1-general/g-7150/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)\n      RETURN departments.department_name%TYPE IS\n      l_department_name departments.department_name%TYPE;\n   BEGIN\n      <<find_department>>\n      BEGIN\n         SELECT department_name\n           INTO l_department_name\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION\n         WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN \n            l_department_name := NULL;\n      END find_department;\n\n      RETURN l_department_name;\n   END name_by_id;\nEND department_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7210/",
            "text": "G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context.\n\n\n\n\nMinor\n\n\nEfficiency, Maintainability\n\n\n\n\nReason\n\n\nThe entire package is loaded into memory when the package is called the first time. To optimize memory consumption and keep load time small packages should be kept small but include components that are used together.",
            "title": "G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7210/#g-7210-try-to-keep-your-packages-small-include-only-few-procedures-and-functions-that-are-used-in-the-same-context",
            "text": "Minor  Efficiency, Maintainability",
            "title": "G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7210/#reason",
            "text": "The entire package is loaded into memory when the package is called the first time. To optimize memory consumption and keep load time small packages should be kept small but include components that are used together.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7220/",
            "text": "G-7220: Always use forward declaration for private functions and procedures.\n\n\n\n\nMinor\n\n\nChangeability\n\n\n\n\nReason\n\n\nHaving forward declarations allows you to order the functions and procedures of the package in a reasonable way. \n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE department_api IS\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE);\nEND department_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)\n      RETURN BOOLEAN IS\n      l_return PLS_INTEGER;\n   BEGIN\n      <<check_row_exists>>\n      BEGIN \n         SELECT 1\n           INTO l_return\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION\n         WHEN no_data_found OR too_many_rows THEN \n            l_return := 0;\n      END check_row_exists;\n\n      RETURN l_return = 1;\n   END does_exist;\n\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE) IS\n   BEGIN\n      IF does_exist(in_department_id) THEN\n        NULL;\n      END IF;\n   END del;\nEND department_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE department_api IS\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE);\nEND department_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)\n      RETURN BOOLEAN;\n\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE) IS\n   BEGIN\n      IF does_exist(in_department_id) THEN\n        NULL;\n      END IF;\n   END del;\n\n   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)\n      RETURN BOOLEAN IS\n      l_return PLS_INTEGER;\n   BEGIN\n      <<check_row_exists>>\n      BEGIN \n         SELECT 1\n           INTO l_return\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION \n         WHEN no_data_found OR too_many_rows THEN\n            l_return := 0;\n      END check_row_exists;\n\n      RETURN l_return = 1;\n   END does_exist;\nEND department_api;\n/",
            "title": "G-7220: Always use forward declaration for private functions and procedures."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7220/#g-7220-always-use-forward-declaration-for-private-functions-and-procedures",
            "text": "Minor  Changeability",
            "title": "G-7220: Always use forward declaration for private functions and procedures."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7220/#reason",
            "text": "Having forward declarations allows you to order the functions and procedures of the package in a reasonable way.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7220/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE department_api IS\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE);\nEND department_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)\n      RETURN BOOLEAN IS\n      l_return PLS_INTEGER;\n   BEGIN\n      <<check_row_exists>>\n      BEGIN \n         SELECT 1\n           INTO l_return\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION\n         WHEN no_data_found OR too_many_rows THEN \n            l_return := 0;\n      END check_row_exists;\n\n      RETURN l_return = 1;\n   END does_exist;\n\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE) IS\n   BEGIN\n      IF does_exist(in_department_id) THEN\n        NULL;\n      END IF;\n   END del;\nEND department_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7220/#example-good",
            "text": "CREATE OR REPLACE PACKAGE department_api IS\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE);\nEND department_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)\n      RETURN BOOLEAN;\n\n   PROCEDURE del (in_department_id IN departments.department_id%TYPE) IS\n   BEGIN\n      IF does_exist(in_department_id) THEN\n        NULL;\n      END IF;\n   END del;\n\n   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)\n      RETURN BOOLEAN IS\n      l_return PLS_INTEGER;\n   BEGIN\n      <<check_row_exists>>\n      BEGIN \n         SELECT 1\n           INTO l_return\n           FROM departments\n          WHERE department_id = in_department_id;\n      EXCEPTION \n         WHEN no_data_found OR too_many_rows THEN\n            l_return := 0;\n      END check_row_exists;\n\n      RETURN l_return = 1;\n   END does_exist;\nEND department_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7230/",
            "text": "G-7230: Avoid declaring global variables public.\n\n\n\n\nMajor\n\n\nReliability\n\n\n\n\nReason\n\n\nYou should always declare package-level data inside the package body. You can then define \"get and set\" methods (functions and procedures, respectively) in the package specification to provide controlled access to that data. By doing so you can guarantee data integrity, you can change your data structure implementation, and also track access to those data structures. \n\n\nData structures (scalar variables, collections, cursors) declared in the package specification (not within any specific program) can be referenced directly by any program running in a session with EXECUTE rights to the package. \n\n\nInstead, declare all package-level data in the package body and provide \"get and set\" methods - a function to get the value and a procedure to set the value - in the package specification. Developers then can access the data using these methods - and will automatically follow all rules you set upon data modification.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE employee_api AS\n   co_min_increase CONSTANT types_up.sal_increase_type := 0.01;\n   co_max_increase CONSTANT types_up.sal_increase_type := 0.5;\n   g_salary_increase types_up.sal_increase_type := co_min_increase;\n\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type);\n   FUNCTION salary_increase RETURN types_up.sal_increase_type;\nEND employee_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type) IS\n   BEGIN\n      g_salary_increase := GREATEST(LEAST(in_increase,co_max_increase)\n                                   ,co_min_increase);\n   END set_salary_increase;\n\n   FUNCTION salary_increase RETURN types_up.sal_increase_type IS\n   BEGIN\n      RETURN g_salary_increase;\n   END salary_increase;\nEND employee_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE employee_api AS\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type);\n   FUNCTION salary_increase RETURN types_up.sal_increase_type;\nEND employee_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   g_salary_increase types_up.sal_increase_type(4,2);\n\n   PROCEDURE init;\n\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type) IS\n   BEGIN\n      g_salary_increase := GREATEST(LEAST(in_increase\n                                         ,constants_up.max_salary_increase())\n                                   ,constants_up.min_salary_increase());\n   END set_salary_increase;\n\n   FUNCTION salary_increase RETURN types_up.sal_increase_type IS\n   BEGIN\n      RETURN g_salary_increase;\n   END salary_increase;\n\n   PROCEDURE init\n   IS\n   BEGIN\n      g_salary_increase := constants_up.min_salary_increase();\n   END init;\nBEGIN\n   init();\nEND employee_api;\n/",
            "title": "G-7230: Avoid declaring global variables public."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7230/#g-7230-avoid-declaring-global-variables-public",
            "text": "Major  Reliability",
            "title": "G-7230: Avoid declaring global variables public."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7230/#reason",
            "text": "You should always declare package-level data inside the package body. You can then define \"get and set\" methods (functions and procedures, respectively) in the package specification to provide controlled access to that data. By doing so you can guarantee data integrity, you can change your data structure implementation, and also track access to those data structures.   Data structures (scalar variables, collections, cursors) declared in the package specification (not within any specific program) can be referenced directly by any program running in a session with EXECUTE rights to the package.   Instead, declare all package-level data in the package body and provide \"get and set\" methods - a function to get the value and a procedure to set the value - in the package specification. Developers then can access the data using these methods - and will automatically follow all rules you set upon data modification.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7230/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE employee_api AS\n   co_min_increase CONSTANT types_up.sal_increase_type := 0.01;\n   co_max_increase CONSTANT types_up.sal_increase_type := 0.5;\n   g_salary_increase types_up.sal_increase_type := co_min_increase;\n\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type);\n   FUNCTION salary_increase RETURN types_up.sal_increase_type;\nEND employee_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type) IS\n   BEGIN\n      g_salary_increase := GREATEST(LEAST(in_increase,co_max_increase)\n                                   ,co_min_increase);\n   END set_salary_increase;\n\n   FUNCTION salary_increase RETURN types_up.sal_increase_type IS\n   BEGIN\n      RETURN g_salary_increase;\n   END salary_increase;\nEND employee_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7230/#example-good",
            "text": "CREATE OR REPLACE PACKAGE employee_api AS\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type);\n   FUNCTION salary_increase RETURN types_up.sal_increase_type;\nEND employee_api;\n/\n\nCREATE OR REPLACE PACKAGE BODY employee_api AS\n   g_salary_increase types_up.sal_increase_type(4,2);\n\n   PROCEDURE init;\n\n   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type) IS\n   BEGIN\n      g_salary_increase := GREATEST(LEAST(in_increase\n                                         ,constants_up.max_salary_increase())\n                                   ,constants_up.min_salary_increase());\n   END set_salary_increase;\n\n   FUNCTION salary_increase RETURN types_up.sal_increase_type IS\n   BEGIN\n      RETURN g_salary_increase;\n   END salary_increase;\n\n   PROCEDURE init\n   IS\n   BEGIN\n      g_salary_increase := constants_up.min_salary_increase();\n   END init;\nBEGIN\n   init();\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7240/",
            "text": "G-7240: Avoid using an IN OUT parameter as IN or OUT only.\n\n\n\n\nMajor\n\n\nEfficiency, Maintainability\n\n\n\n\nReason\n\n\nBy showing the mode of parameters, you help the reader. If you do not specify a parameter mode, the default mode is \nIN\n. Explicitly showing the mode indication of all parameters is a more assertive action than simply taking the default mode. Anyone reviewing the code later will be more confident that you intended the parameter mode to be \nIN\n / \nOUT\n.\n\n\nExample (bad)\n\n\n-- Bad\nCREATE OR REPLACE PACKAGE BODY employee_up IS\n   PROCEDURE rcv_emp (io_first_name     IN OUT employees.first_name%TYPE\n                     ,io_last_name      IN OUT employees.last_name%TYPE \n                     ,io_email          IN OUT employees.email%TYPE \n                     ,io_phone_number   IN OUT employees.phone_number%TYPE\n                     ,io_hire_date      IN OUT employees.hire_date%TYPE \n                     ,io_job_id         IN OUT employees.job_id%TYPE\n                     ,io_salary         IN OUT employees.salary%TYPE\n                     ,io_commission_pct IN OUT employees.commission_pct%TYPE \n                     ,io_manager_id     IN OUT employees.manager_id%TYPE\n                     ,io_department_id  IN OUT employees.department_id%TYPE\n                     ,in_wait                  INTEGER) IS\n      l_status PLS_INTEGER;\n      co_dflt_pipe_name CONSTANT STRING(30 CHAR) := 'MyPipe';\n      co_ok CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      -- Receive next message and unpack for each column. \n      l_status := SYS.dbms_pipe.receive_message(pipename => co_dflt_pipe_name\n                                               ,timeout  => in_wait);\n      IF l_status = co_ok THEN\n         SYS.dbms_pipe.unpack_message (io_first_name);\n         SYS.dbms_pipe.unpack_message (io_last_name);\n         SYS.dbms_pipe.unpack_message (io_email);\n         SYS.dbms_pipe.unpack_message (io_phone_number);\n         SYS.dbms_pipe.unpack_message (io_hire_date);\n         SYS.dbms_pipe.unpack_message (io_job_id);\n         SYS.dbms_pipe.unpack_message (io_salary);\n         SYS.dbms_pipe.unpack_message (io_commission_pct);\n         SYS.dbms_pipe.unpack_message (io_manager_id);\n         SYS.dbms_pipe.unpack_message (io_department_id);\n      END IF;\n   END rcv_emp;\nEND employee_up;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_up IS\n   PROCEDURE rcv_emp (OUT_first_name     OUT employees.first_name%TYPE\n                     ,OUT_last_name      OUT employees.last_name%TYPE \n                     ,OUT_email          OUT employees.email%TYPE \n                     ,OUT_phone_number   OUT employees.phone_number%TYPE\n                     ,OUT_hire_date      OUT employees.hire_date%TYPE \n                     ,OUT_job_id         OUT employees.job_id%TYPE\n                     ,OUT_salary         OUT employees.salary%TYPE\n                     ,OUT_commission_pct OUT employees.commission_pct%TYPE \n                     ,OUT_manager_id     OUT employees.manager_id%TYPE\n                     ,OUT_department_id  OUT employees.department_id%TYPE\n                     ,in_wait            IN     INTEGER) IS\n      l_status PLS_INTEGER;\n      co_dflt_pipe_name CONSTANT STRING(30 CHAR) := 'MyPipe';\n      co_ok CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      -- Receive next message and unpack for each column. \n      l_status := SYS.dbms_pipe.receive_message(pipename => co_dflt_pipe_name\n                                               ,timeout  => in_wait);\n      IF l_status = co_ok THEN\n         SYS.dbms_pipe.unpack_message (out_first_name);\n         SYS.dbms_pipe.unpack_message (out_last_name);\n         SYS.dbms_pipe.unpack_message (out_email);\n         SYS.dbms_pipe.unpack_message (out_phone_number);\n         SYS.dbms_pipe.unpack_message (out_hire_date);\n         SYS.dbms_pipe.unpack_message (out_job_id);\n         SYS.dbms_pipe.unpack_message (out_salary);\n         SYS.dbms_pipe.unpack_message (out_commission_pct);\n         SYS.dbms_pipe.unpack_message (out_manager_id);\n         SYS.dbms_pipe.unpack_message (out_department_id);\n      END IF;\n   END rcv_emp;\nEND employee_up;\n/",
            "title": "G-7240: Avoid using an IN OUT parameter as IN or OUT only."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7240/#g-7240-avoid-using-an-in-out-parameter-as-in-or-out-only",
            "text": "Major  Efficiency, Maintainability",
            "title": "G-7240: Avoid using an IN OUT parameter as IN or OUT only."
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7240/#reason",
            "text": "By showing the mode of parameters, you help the reader. If you do not specify a parameter mode, the default mode is  IN . Explicitly showing the mode indication of all parameters is a more assertive action than simply taking the default mode. Anyone reviewing the code later will be more confident that you intended the parameter mode to be  IN  /  OUT .",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7240/#example-bad",
            "text": "-- Bad\nCREATE OR REPLACE PACKAGE BODY employee_up IS\n   PROCEDURE rcv_emp (io_first_name     IN OUT employees.first_name%TYPE\n                     ,io_last_name      IN OUT employees.last_name%TYPE \n                     ,io_email          IN OUT employees.email%TYPE \n                     ,io_phone_number   IN OUT employees.phone_number%TYPE\n                     ,io_hire_date      IN OUT employees.hire_date%TYPE \n                     ,io_job_id         IN OUT employees.job_id%TYPE\n                     ,io_salary         IN OUT employees.salary%TYPE\n                     ,io_commission_pct IN OUT employees.commission_pct%TYPE \n                     ,io_manager_id     IN OUT employees.manager_id%TYPE\n                     ,io_department_id  IN OUT employees.department_id%TYPE\n                     ,in_wait                  INTEGER) IS\n      l_status PLS_INTEGER;\n      co_dflt_pipe_name CONSTANT STRING(30 CHAR) := 'MyPipe';\n      co_ok CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      -- Receive next message and unpack for each column. \n      l_status := SYS.dbms_pipe.receive_message(pipename => co_dflt_pipe_name\n                                               ,timeout  => in_wait);\n      IF l_status = co_ok THEN\n         SYS.dbms_pipe.unpack_message (io_first_name);\n         SYS.dbms_pipe.unpack_message (io_last_name);\n         SYS.dbms_pipe.unpack_message (io_email);\n         SYS.dbms_pipe.unpack_message (io_phone_number);\n         SYS.dbms_pipe.unpack_message (io_hire_date);\n         SYS.dbms_pipe.unpack_message (io_job_id);\n         SYS.dbms_pipe.unpack_message (io_salary);\n         SYS.dbms_pipe.unpack_message (io_commission_pct);\n         SYS.dbms_pipe.unpack_message (io_manager_id);\n         SYS.dbms_pipe.unpack_message (io_department_id);\n      END IF;\n   END rcv_emp;\nEND employee_up;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/2-packages/g-7240/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_up IS\n   PROCEDURE rcv_emp (OUT_first_name     OUT employees.first_name%TYPE\n                     ,OUT_last_name      OUT employees.last_name%TYPE \n                     ,OUT_email          OUT employees.email%TYPE \n                     ,OUT_phone_number   OUT employees.phone_number%TYPE\n                     ,OUT_hire_date      OUT employees.hire_date%TYPE \n                     ,OUT_job_id         OUT employees.job_id%TYPE\n                     ,OUT_salary         OUT employees.salary%TYPE\n                     ,OUT_commission_pct OUT employees.commission_pct%TYPE \n                     ,OUT_manager_id     OUT employees.manager_id%TYPE\n                     ,OUT_department_id  OUT employees.department_id%TYPE\n                     ,in_wait            IN     INTEGER) IS\n      l_status PLS_INTEGER;\n      co_dflt_pipe_name CONSTANT STRING(30 CHAR) := 'MyPipe';\n      co_ok CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      -- Receive next message and unpack for each column. \n      l_status := SYS.dbms_pipe.receive_message(pipename => co_dflt_pipe_name\n                                               ,timeout  => in_wait);\n      IF l_status = co_ok THEN\n         SYS.dbms_pipe.unpack_message (out_first_name);\n         SYS.dbms_pipe.unpack_message (out_last_name);\n         SYS.dbms_pipe.unpack_message (out_email);\n         SYS.dbms_pipe.unpack_message (out_phone_number);\n         SYS.dbms_pipe.unpack_message (out_hire_date);\n         SYS.dbms_pipe.unpack_message (out_job_id);\n         SYS.dbms_pipe.unpack_message (out_salary);\n         SYS.dbms_pipe.unpack_message (out_commission_pct);\n         SYS.dbms_pipe.unpack_message (out_manager_id);\n         SYS.dbms_pipe.unpack_message (out_department_id);\n      END IF;\n   END rcv_emp;\nEND employee_up;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7310/",
            "text": "G-7310: Avoid standalone procedures \u2013 put your procedures in packages.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nUse packages to structure your code, combine procedures and functions which belong together.\n\n\nPackage bodies may be changed and compiled without invalidating other packages. This is major advantage compared to standalone procedures and functions.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PROCEDURE my_procedure IS\nBEGIN\n   NULL;\nEND my_procedure;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE my_package IS\n   PROCEDURE my_procedure;\nEND my_package;\n/\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n   BEGIN\n      NULL;\n   END my_procedure;\nEND my_package;\n/",
            "title": "G-7310: Avoid standalone procedures \u2013 put your procedures in packages."
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7310/#g-7310-avoid-standalone-procedures-put-your-procedures-in-packages",
            "text": "Minor  Maintainability",
            "title": "G-7310: Avoid standalone procedures \u2013 put your procedures in packages."
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7310/#reason",
            "text": "Use packages to structure your code, combine procedures and functions which belong together.  Package bodies may be changed and compiled without invalidating other packages. This is major advantage compared to standalone procedures and functions.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7310/#example-bad",
            "text": "CREATE OR REPLACE PROCEDURE my_procedure IS\nBEGIN\n   NULL;\nEND my_procedure;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7310/#example-good",
            "text": "CREATE OR REPLACE PACKAGE my_package IS\n   PROCEDURE my_procedure;\nEND my_package;\n/\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n   BEGIN\n      NULL;\n   END my_procedure;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7320/",
            "text": "G-7320: Avoid using RETURN statements in a PROCEDURE.\n\n\n\n\nMajor\n\n\nMaintainability, Testability\n\n\n\n\nReason\n\n\nUse of the \nRETURN\n statement is legal within a procedure in PL/SQL, but it is very similar to a \nGOTO\n, which means you end up with poorly structured code that is hard to debug and maintain. \n\n\nA good general rule to follow as you write your PL/SQL programs is \"one way in and one way out\". In other words, there should be just one way to enter or call a program, and there should be one way out, one exit path from a program (or loop) on successful termination. By following this rule, you end up with code that is much easier to trace, debug, and maintain.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      l_idx SIMPLE_INTEGER := 1;\n      co_modulo CONSTANT SIMPLE_INTEGER := 7;\n   BEGIN\n      <<mod7_loop>>\n      LOOP\n        IF MOD(l_idx,co_modulo) = 0 THEN\n           RETURN;\n        END IF;\n\n        l_idx := l_idx + 1;\n      END LOOP mod7_loop;\n   END my_procedure;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      l_idx SIMPLE_INTEGER := 1;\n      co_modulo CONSTANT SIMPLE_INTEGER := 7;\n   BEGIN\n      <<mod7_loop>>\n      LOOP\n        EXIT mod7_loop WHEN MOD(l_idx,co_modulo) = 0;\n\n        l_idx := l_idx + 1;\n      END LOOP mod7_loop;\n   END my_procedure;\nEND my_package;\n/",
            "title": "G-7320: Avoid using RETURN statements in a PROCEDURE."
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7320/#g-7320-avoid-using-return-statements-in-a-procedure",
            "text": "Major  Maintainability, Testability",
            "title": "G-7320: Avoid using RETURN statements in a PROCEDURE."
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7320/#reason",
            "text": "Use of the  RETURN  statement is legal within a procedure in PL/SQL, but it is very similar to a  GOTO , which means you end up with poorly structured code that is hard to debug and maintain.   A good general rule to follow as you write your PL/SQL programs is \"one way in and one way out\". In other words, there should be just one way to enter or call a program, and there should be one way out, one exit path from a program (or loop) on successful termination. By following this rule, you end up with code that is much easier to trace, debug, and maintain.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7320/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      l_idx SIMPLE_INTEGER := 1;\n      co_modulo CONSTANT SIMPLE_INTEGER := 7;\n   BEGIN\n      <<mod7_loop>>\n      LOOP\n        IF MOD(l_idx,co_modulo) = 0 THEN\n           RETURN;\n        END IF;\n\n        l_idx := l_idx + 1;\n      END LOOP mod7_loop;\n   END my_procedure;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/3-procedures/g-7320/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   PROCEDURE my_procedure IS\n      l_idx SIMPLE_INTEGER := 1;\n      co_modulo CONSTANT SIMPLE_INTEGER := 7;\n   BEGIN\n      <<mod7_loop>>\n      LOOP\n        EXIT mod7_loop WHEN MOD(l_idx,co_modulo) = 0;\n\n        l_idx := l_idx + 1;\n      END LOOP mod7_loop;\n   END my_procedure;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7410/",
            "text": "G-7410: Avoid standalone functions \u2013 put your functions in packages.\n\n\n\n\nMinor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nUse packages to structure your code, combine procedures and functions which belong together.\n\n\nPackage bodies may be changed and compiled without invalidating other packages. This is major advantage compared to standalone procedures and functions.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE FUNCTION my_function RETURN VARCHAR2 IS\nBEGIN\n   RETURN NULL;\nEND my_function;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN VARCHAR2 IS\n   BEGIN\n      RETURN NULL;\n   END my_function;\nEND my_package;\n/",
            "title": "G-7410: Avoid standalone functions \u2013 put your functions in packages."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7410/#g-7410-avoid-standalone-functions-put-your-functions-in-packages",
            "text": "Minor  Maintainability",
            "title": "G-7410: Avoid standalone functions \u2013 put your functions in packages."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7410/#reason",
            "text": "Use packages to structure your code, combine procedures and functions which belong together.  Package bodies may be changed and compiled without invalidating other packages. This is major advantage compared to standalone procedures and functions.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7410/#example-bad",
            "text": "CREATE OR REPLACE FUNCTION my_function RETURN VARCHAR2 IS\nBEGIN\n   RETURN NULL;\nEND my_function;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7410/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN VARCHAR2 IS\n   BEGIN\n      RETURN NULL;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7420/",
            "text": "G-7420: Always make the RETURN statement the last statement of your function.\n\n\n\n\nMajor\n\n\nMaintainability\n\n\n\n\nReason\n\n\nThe reader expects the RETURN statement to be the last statement of a function.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_from IN PLS_INTEGER\n                       , in_to   IN PLS_INTEGER) RETURN PLS_INTEGER IS\n      l_ret PLS_INTEGER;\n   BEGIN\n      l_ret := in_from;\n      <<for_loop>>\n      FOR i IN in_from .. in_to \n      LOOP\n         l_ret := l_ret + i;\n         IF i = in_to THEN\n            RETURN l_ret;\n         END IF;\n      END LOOP for_loop;\n   END my_function;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_from IN PLS_INTEGER\n                       , in_to   IN PLS_INTEGER) RETURN PLS_INTEGER IS\n      l_ret PLS_INTEGER;\n   BEGIN\n      l_ret := in_from;\n      <<for_loop>>\n      FOR i IN in_from .. in_to \n      LOOP\n         l_ret := l_ret + i;\n      END LOOP for_loop;\n      RETURN l_ret;\n   END my_function;\nEND my_package;\n/",
            "title": "G-7420: Always make the RETURN statement the last statement of your function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7420/#g-7420-always-make-the-return-statement-the-last-statement-of-your-function",
            "text": "Major  Maintainability",
            "title": "G-7420: Always make the RETURN statement the last statement of your function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7420/#reason",
            "text": "The reader expects the RETURN statement to be the last statement of a function.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7420/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_from IN PLS_INTEGER\n                       , in_to   IN PLS_INTEGER) RETURN PLS_INTEGER IS\n      l_ret PLS_INTEGER;\n   BEGIN\n      l_ret := in_from;\n      <<for_loop>>\n      FOR i IN in_from .. in_to \n      LOOP\n         l_ret := l_ret + i;\n         IF i = in_to THEN\n            RETURN l_ret;\n         END IF;\n      END LOOP for_loop;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7420/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_from IN PLS_INTEGER\n                       , in_to   IN PLS_INTEGER) RETURN PLS_INTEGER IS\n      l_ret PLS_INTEGER;\n   BEGIN\n      l_ret := in_from;\n      <<for_loop>>\n      FOR i IN in_from .. in_to \n      LOOP\n         l_ret := l_ret + i;\n      END LOOP for_loop;\n      RETURN l_ret;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7430/",
            "text": "G-7430: Try to use no more than one RETURN statement within a function.\n\n\n\n\nMajor\n\n\nWill have a medium/potential impact on the maintenance cost.\nMaintainability, Testability\n\n\n\n\nReason\n\n\nA function should have a single point of entry as well as a single exit-point.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS\n      co_yes CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      IF in_value = co_yes THEN\n         RETURN TRUE;\n      ELSE\n         RETURN FALSE;\n      END IF;\n   END my_function;\nEND my_package;\n/\n\n\n\n\nExample (better)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS\n      co_yes CONSTANT PLS_INTEGER := 1;\n      l_ret BOOLEAN;\n   BEGIN\n      IF in_value = co_yes THEN\n         l_ret := TRUE;\n      ELSE\n         l_ret := FALSE;\n      END IF;\n\n\n  RETURN l_ret;\n\n\n\nEND my_function;\nEND my_package;\n/\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS\n      co_yes CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      RETURN in_value = co_yes;\n   END my_function;\nEND my_package;\n/",
            "title": "G-7430: Try to use no more than one RETURN statement within a function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7430/#g-7430-try-to-use-no-more-than-one-return-statement-within-a-function",
            "text": "Major  Will have a medium/potential impact on the maintenance cost.\nMaintainability, Testability",
            "title": "G-7430: Try to use no more than one RETURN statement within a function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7430/#reason",
            "text": "A function should have a single point of entry as well as a single exit-point.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7430/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS\n      co_yes CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      IF in_value = co_yes THEN\n         RETURN TRUE;\n      ELSE\n         RETURN FALSE;\n      END IF;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7430/#example-better",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS\n      co_yes CONSTANT PLS_INTEGER := 1;\n      l_ret BOOLEAN;\n   BEGIN\n      IF in_value = co_yes THEN\n         l_ret := TRUE;\n      ELSE\n         l_ret := FALSE;\n      END IF;    RETURN l_ret;  END my_function;\nEND my_package;\n/",
            "title": "Example (better)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7430/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS\n      co_yes CONSTANT PLS_INTEGER := 1;\n   BEGIN\n      RETURN in_value = co_yes;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7440/",
            "text": "G-7440: Never use OUT parameters to return values from a function.\n\n\n\n\nMajor\n\n\nReusability\n\n\n\n\nReason\n\n\nA function should return all its data through the RETURN clause. Having an OUT parameter prohibits usage of a function within SQL statements.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (out_date OUT DATE) RETURN BOOLEAN IS\n   BEGIN\n      out_date := SYSDATE;\n      RETURN TRUE;\n   END my_function;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN DATE IS\n   BEGIN\n      RETURN SYSDATE;\n   END my_function;\nEND my_package;\n/",
            "title": "G-7440: Never use OUT parameters to return values from a function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7440/#g-7440-never-use-out-parameters-to-return-values-from-a-function",
            "text": "Major  Reusability",
            "title": "G-7440: Never use OUT parameters to return values from a function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7440/#reason",
            "text": "A function should return all its data through the RETURN clause. Having an OUT parameter prohibits usage of a function within SQL statements.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7440/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function (out_date OUT DATE) RETURN BOOLEAN IS\n   BEGIN\n      out_date := SYSDATE;\n      RETURN TRUE;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7440/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN DATE IS\n   BEGIN\n      RETURN SYSDATE;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7450/",
            "text": "G-7450: Never return a NULL value from a BOOLEAN function.\n\n\n\n\nMajor\n\n\nReliability, Testability\n\n\n\n\nReason\n\n\nIf a boolean function returns null, the caller has do deal with it. This makes the usage cumbersome and more error-prone.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN BOOLEAN IS\n   BEGIN\n      RETURN NULL;\n   END my_function;\nEND my_package;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN BOOLEAN IS\n   BEGIN\n      RETURN TRUE;\n   END my_function;\nEND my_package;\n/",
            "title": "G-7450: Never return a NULL value from a BOOLEAN function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7450/#g-7450-never-return-a-null-value-from-a-boolean-function",
            "text": "Major  Reliability, Testability",
            "title": "G-7450: Never return a NULL value from a BOOLEAN function."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7450/#reason",
            "text": "If a boolean function returns null, the caller has do deal with it. This makes the usage cumbersome and more error-prone.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7450/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN BOOLEAN IS\n   BEGIN\n      RETURN NULL;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7450/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY my_package IS\n   FUNCTION my_function RETURN BOOLEAN IS\n   BEGIN\n      RETURN TRUE;\n   END my_function;\nEND my_package;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7460/",
            "text": "G-7460: Try to define your packaged/standalone function deterministic if appropriate.\n\n\n\n\nMajor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nA deterministic function (always return same result for identical parameters) which is defined to be deterministic will be executed once per different parameter within a SQL statement whereas if the function is not defined to be deterministic it is executed once per result row.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)\n      RETURN departments.department_name%TYPE;\nEND department_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)\n      RETURN departments.department_name%TYPE DETERMINISTIC;\nEND department_api;\n/",
            "title": "G-7460: Try to define your packaged/standalone function deterministic if appropriate."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7460/#g-7460-try-to-define-your-packagedstandalone-function-deterministic-if-appropriate",
            "text": "Major  Efficiency",
            "title": "G-7460: Try to define your packaged/standalone function deterministic if appropriate."
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7460/#reason",
            "text": "A deterministic function (always return same result for identical parameters) which is defined to be deterministic will be executed once per different parameter within a SQL statement whereas if the function is not defined to be deterministic it is executed once per result row.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7460/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)\n      RETURN departments.department_name%TYPE;\nEND department_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/4-functions/g-7460/#example-good",
            "text": "CREATE OR REPLACE PACKAGE department_api IS\n   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)\n      RETURN departments.department_name%TYPE DETERMINISTIC;\nEND department_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/",
            "text": "G-7510: Always prefix ORACLE supplied packages with owner schema name.\n\n\n\n\nMajor\n\n\nSecurity\n\n\n\n\nReason\n\n\nThe signature of oracle-supplied packages is well known and therefore it is quite easy to provide packages with the same name as those from oracle doing something completely different without you noticing it.\n\n\nExample (bad)\n\n\nDECLARE\n   co_hello_world CONSTANT STRING(30 CHAR) := 'Hello World';\nBEGIN\n   dbms_output.put_line(co_hello_world);\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_hello_world CONSTANT STRING(30 CHAR) := 'Hello World';\nBEGIN\n   sys.dbms_output.put_line(co_hello_world);\nEND;\n/",
            "title": "G-7510: Always prefix ORACLE supplied packages with owner schema name."
        },
        {
            "location": "/4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#g-7510-always-prefix-oracle-supplied-packages-with-owner-schema-name",
            "text": "Major  Security",
            "title": "G-7510: Always prefix ORACLE supplied packages with owner schema name."
        },
        {
            "location": "/4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#reason",
            "text": "The signature of oracle-supplied packages is well known and therefore it is quite easy to provide packages with the same name as those from oracle doing something completely different without you noticing it.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#example-bad",
            "text": "DECLARE\n   co_hello_world CONSTANT STRING(30 CHAR) := 'Hello World';\nBEGIN\n   dbms_output.put_line(co_hello_world);\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#example-good",
            "text": "DECLARE\n   co_hello_world CONSTANT STRING(30 CHAR) := 'Hello World';\nBEGIN\n   sys.dbms_output.put_line(co_hello_world);\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/6-object-types/object-types/",
            "text": "Object Types\n\n\nThere are no object type-specific recommendations to be defined at the time of writing.",
            "title": "Object Types"
        },
        {
            "location": "/4-language-usage/7-stored-objects/6-object-types/object-types/#object-types",
            "text": "There are no object type-specific recommendations to be defined at the time of writing.",
            "title": "Object Types"
        },
        {
            "location": "/4-language-usage/7-stored-objects/7-triggers/g-7710/",
            "text": "G-7710: Avoid cascading triggers.\n\n\n\n\nMajor\n\n\nMaintainability, Testability\n\n\n\n\nReason\n\n\nHaving triggers that act on other tables in a way that causes triggers on that table to fire lead to obscure behavior. \n\n\nExample (bad)\n\n\nCREATE OR REPLACE TRIGGER dept_br_u\nBEFORE UPDATE ON departments FOR EACH ROW\nBEGIN\n   INSERT INTO departments_hist (department_id\n                                ,department_name\n                                ,manager_id\n                                ,location_id\n                                ,modification_date) \n        VALUES (:OLD.department_id\n               ,:OLD.department_name\n               ,:OLD.manager_id\n               ,:OLD.location_id\n               ,SYSDATE);\nEND;\n/ \nCREATE OR REPLACE TRIGGER dept_hist_br_i\nBEFORE INSERT ON departments_hist FOR EACH ROW\nBEGIN\n   INSERT INTO departments_log (department_id\n                               ,department_name\n                               ,modification_date) \n                        VALUES (:NEW.department_id\n                               ,:NEW.department_name\n                               ,SYSDATE);\nEND;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE TRIGGER dept_br_u\nBEFORE UPDATE ON departments FOR EACH ROW\nBEGIN\n   INSERT INTO departments_hist (department_id\n                                ,department_name\n                                ,manager_id\n                                ,location_id\n                                ,modification_date) \n        VALUES (:OLD.department_id\n               ,:OLD.department_name\n               ,:OLD.manager_id\n               ,:OLD.location_id\n               ,SYSDATE);\n\n   INSERT INTO departments_log (department_id\n                               ,department_name\n                               ,modification_date) \n                        VALUES (:OLD.department_id\n                               ,:OLD.department_name\n                               ,SYSDATE);\n\nEND;\n/",
            "title": "G-7710: Avoid cascading triggers."
        },
        {
            "location": "/4-language-usage/7-stored-objects/7-triggers/g-7710/#g-7710-avoid-cascading-triggers",
            "text": "Major  Maintainability, Testability",
            "title": "G-7710: Avoid cascading triggers."
        },
        {
            "location": "/4-language-usage/7-stored-objects/7-triggers/g-7710/#reason",
            "text": "Having triggers that act on other tables in a way that causes triggers on that table to fire lead to obscure behavior.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/7-triggers/g-7710/#example-bad",
            "text": "CREATE OR REPLACE TRIGGER dept_br_u\nBEFORE UPDATE ON departments FOR EACH ROW\nBEGIN\n   INSERT INTO departments_hist (department_id\n                                ,department_name\n                                ,manager_id\n                                ,location_id\n                                ,modification_date) \n        VALUES (:OLD.department_id\n               ,:OLD.department_name\n               ,:OLD.manager_id\n               ,:OLD.location_id\n               ,SYSDATE);\nEND;\n/ \nCREATE OR REPLACE TRIGGER dept_hist_br_i\nBEFORE INSERT ON departments_hist FOR EACH ROW\nBEGIN\n   INSERT INTO departments_log (department_id\n                               ,department_name\n                               ,modification_date) \n                        VALUES (:NEW.department_id\n                               ,:NEW.department_name\n                               ,SYSDATE);\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/7-triggers/g-7710/#example-good",
            "text": "CREATE OR REPLACE TRIGGER dept_br_u\nBEFORE UPDATE ON departments FOR EACH ROW\nBEGIN\n   INSERT INTO departments_hist (department_id\n                                ,department_name\n                                ,manager_id\n                                ,location_id\n                                ,modification_date) \n        VALUES (:OLD.department_id\n               ,:OLD.department_name\n               ,:OLD.manager_id\n               ,:OLD.location_id\n               ,SYSDATE);\n\n   INSERT INTO departments_log (department_id\n                               ,department_name\n                               ,modification_date) \n                        VALUES (:OLD.department_id\n                               ,:OLD.department_name\n                               ,SYSDATE);\n\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/8-sequences/g-7810/",
            "text": "G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE).\n\n\n\n\nMajor\n\n\nEfficiency, Maintainability\n\n\n\n\nReason\n\n\nSince ORACLE 11g it is no longer needed to use a SELECT statement to read a sequence (which would imply a context switch).\n\n\nExample (bad)\n\n\nDECLARE\n   l_sequence_number employees.emloyee_id%type;\nBEGIN\n   SELECT employees_seq.NEXTVAL\n     INTO l_sequence_number\n     FROM DUAL;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   l_sequence_number employees.emloyee_id%type;\nBEGIN\n   l_sequence_number := employees_seq.NEXTVAL;\nEND;\n/",
            "title": "G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE)."
        },
        {
            "location": "/4-language-usage/7-stored-objects/8-sequences/g-7810/#g-7810-never-use-sql-inside-plsql-to-read-sequence-numbers-or-sysdate",
            "text": "Major  Efficiency, Maintainability",
            "title": "G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE)."
        },
        {
            "location": "/4-language-usage/7-stored-objects/8-sequences/g-7810/#reason",
            "text": "Since ORACLE 11g it is no longer needed to use a SELECT statement to read a sequence (which would imply a context switch).",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/7-stored-objects/8-sequences/g-7810/#example-bad",
            "text": "DECLARE\n   l_sequence_number employees.emloyee_id%type;\nBEGIN\n   SELECT employees_seq.NEXTVAL\n     INTO l_sequence_number\n     FROM DUAL;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/7-stored-objects/8-sequences/g-7810/#example-good",
            "text": "DECLARE\n   l_sequence_number employees.emloyee_id%type;\nBEGIN\n   l_sequence_number := employees_seq.NEXTVAL;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/",
            "text": "G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row.\n\n\n\n\nMajor\n\n\nEfficiency\n\n\n\n\nReason\n\n\nIf you do a SELECT count(\n) all rows will be read according to the WHERE clause, even if only the availability of data is of interest. For this we have a big performance overhead. If we do a SELECT count(\n) ... WHERE ROWNUM = 1 there is also a overhead as there will be two communications between the PL/SQL and the SQL engine. See the following example for a better solution.\n\n\nExample (bad)\n\n\nDECLARE\n   l_count PLS_INTEGER;\n   co_zero   CONSTANT SIMPLE_INTEGER := 0;\n   co_salary CONSTANT employees.salary%TYPE := 5000;\nBEGIN\n   SELECT count(*)\n     INTO l_count\n     FROM employees\n    WHERE salary < co_salary;\n    IF l_count > co_zero THEN\n       <<emp_loop>>\n       FOR r_emp IN (SELECT employee_id\n                       FROM employees)\n       LOOP\n          IF r_emp.salary < co_salary THEN\n             my_package.my_proc(in_employee_id => r_emp.employee_id); \n          END IF;\n       END LOOP emp_loop;\n    END IF;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nDECLARE\n   co_salary CONSTANT employees.salary%TYPE := 5000;\nBEGIN\n    <<emp_loop>>\n    FOR r_emp IN (SELECT e1.employee_id\n                    FROM employees e1\n                   WHERE EXISTS(SELECT e2.salary\n                                  FROM employees e2\n                                 WHERE e2.salary < co_salary))\n    LOOP\n       my_package.my_proc(in_employee_id => r_emp.employee_id); \n    END LOOP emp_loop;\nEND;\n/",
            "title": "G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row."
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#g-8110-never-use-select-count-if-you-are-only-interested-in-the-existence-of-a-row",
            "text": "Major  Efficiency",
            "title": "G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row."
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#reason",
            "text": "If you do a SELECT count( ) all rows will be read according to the WHERE clause, even if only the availability of data is of interest. For this we have a big performance overhead. If we do a SELECT count( ) ... WHERE ROWNUM = 1 there is also a overhead as there will be two communications between the PL/SQL and the SQL engine. See the following example for a better solution.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#example-bad",
            "text": "DECLARE\n   l_count PLS_INTEGER;\n   co_zero   CONSTANT SIMPLE_INTEGER := 0;\n   co_salary CONSTANT employees.salary%TYPE := 5000;\nBEGIN\n   SELECT count(*)\n     INTO l_count\n     FROM employees\n    WHERE salary < co_salary;\n    IF l_count > co_zero THEN\n       <<emp_loop>>\n       FOR r_emp IN (SELECT employee_id\n                       FROM employees)\n       LOOP\n          IF r_emp.salary < co_salary THEN\n             my_package.my_proc(in_employee_id => r_emp.employee_id); \n          END IF;\n       END LOOP emp_loop;\n    END IF;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#example-good",
            "text": "DECLARE\n   co_salary CONSTANT employees.salary%TYPE := 5000;\nBEGIN\n    <<emp_loop>>\n    FOR r_emp IN (SELECT e1.employee_id\n                    FROM employees e1\n                   WHERE EXISTS(SELECT e2.salary\n                                  FROM employees e2\n                                 WHERE e2.salary < co_salary))\n    LOOP\n       my_package.my_proc(in_employee_id => r_emp.employee_id); \n    END LOOP emp_loop;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/",
            "text": "G-8120: Never check existence of a row to decide whether to create it or not.\n\n\n\n\nMajor\n\n\nEfficiency, Reliability\n\n\n\n\nReason\n\n\nThe result of an existence check is a snapshot of the current situation. You never know whether in the time between the check and the (insert) action someone else has decided to create a row with the values you checked. Therefore, you should only rely on constraints when it comes to preventioin of duplicate records.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   PROCEDURE ins (in_r_department IN departments%ROWTYPE) IS\n      l_count PLS_INTEGER;\n   BEGIN\n      SELECT count(*)\n        INTO l_count\n        FROM departments\n       WHERE department_id = in_r_department.department_id;\n\n       IF l_count = 0 THEN\n          INSERT INTO departments\n               VALUES in_r_department;\n       END IF;\n   END ins;\nEND department_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   PROCEDURE ins (in_r_department IN departments%ROWTYPE) IS\n   BEGIN\n      INSERT INTO departments\n           VALUES in_r_department;\n   EXCEPTION\n      WHEN dup_val_on_index THEN NULL; -- handle exception\n   END ins;\nEND department_api;\n/",
            "title": "G-8120: Never check existence of a row to decide whether to create it or not."
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#g-8120-never-check-existence-of-a-row-to-decide-whether-to-create-it-or-not",
            "text": "Major  Efficiency, Reliability",
            "title": "G-8120: Never check existence of a row to decide whether to create it or not."
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#reason",
            "text": "The result of an existence check is a snapshot of the current situation. You never know whether in the time between the check and the (insert) action someone else has decided to create a row with the values you checked. Therefore, you should only rely on constraints when it comes to preventioin of duplicate records.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   PROCEDURE ins (in_r_department IN departments%ROWTYPE) IS\n      l_count PLS_INTEGER;\n   BEGIN\n      SELECT count(*)\n        INTO l_count\n        FROM departments\n       WHERE department_id = in_r_department.department_id;\n\n       IF l_count = 0 THEN\n          INSERT INTO departments\n               VALUES in_r_department;\n       END IF;\n   END ins;\nEND department_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   PROCEDURE ins (in_r_department IN departments%ROWTYPE) IS\n   BEGIN\n      INSERT INTO departments\n           VALUES in_r_department;\n   EXCEPTION\n      WHEN dup_val_on_index THEN NULL; -- handle exception\n   END ins;\nEND department_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/",
            "text": "G-8210: Always use synonyms when accessing objects of another application schema.\n\n\n\n\nMajor\n\n\nChangeability, Maintainability\n\n\n\n\nReason\n\n\nIf a connection is needed to a table that is placed in a foreign schema, using synonyms is a good choice. If there are structural changes to that table (e.g. the table name changes or the table changes into another schema) only the synonym has to be changed no changes to the package are needed (single point of change). If you only have read access for a table inside another schema, or there is another reason that does not allow you to change data in this table, you can switch the synonym to a table in your own schema.  This is also good practice for testers working on test systems.\n\n\nExample (bad)\n\n\nDECLARE\n   l_product_name oe.products.product_name%TYPE;\n   co_price CONSTANT oe.products@list_price%TYPE := 1000;\nBEGIN\n   SELECT p.product_name\n     INTO l_product_name\n     FROM oe.products p\n    WHERE list_price > co_price;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN\n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN\n      NULL; -- handle_too_many_rows;\nEND;\n/\n\n\n\n\nExample (good)\n\n\nCREATE SYNONYM oe_products FOR oe.products;\n\nDECLARE\n   l_product_name oe_products.product_name%TYPE;\n   co_price CONSTANT oe_products.list_price%TYPE := 1000;\nBEGIN\n   SELECT p.product_name\n     INTO l_product_name\n     FROM oe_products p\n    WHERE list_price > co_price;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN\n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN\n      NULL; -- handle_too_many_rows;\nEND;\n/",
            "title": "G-8210: Always use synonyms when accessing objects of another application schema."
        },
        {
            "location": "/4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#g-8210-always-use-synonyms-when-accessing-objects-of-another-application-schema",
            "text": "Major  Changeability, Maintainability",
            "title": "G-8210: Always use synonyms when accessing objects of another application schema."
        },
        {
            "location": "/4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#reason",
            "text": "If a connection is needed to a table that is placed in a foreign schema, using synonyms is a good choice. If there are structural changes to that table (e.g. the table name changes or the table changes into another schema) only the synonym has to be changed no changes to the package are needed (single point of change). If you only have read access for a table inside another schema, or there is another reason that does not allow you to change data in this table, you can switch the synonym to a table in your own schema.  This is also good practice for testers working on test systems.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#example-bad",
            "text": "DECLARE\n   l_product_name oe.products.product_name%TYPE;\n   co_price CONSTANT oe.products@list_price%TYPE := 1000;\nBEGIN\n   SELECT p.product_name\n     INTO l_product_name\n     FROM oe.products p\n    WHERE list_price > co_price;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN\n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN\n      NULL; -- handle_too_many_rows;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#example-good",
            "text": "CREATE SYNONYM oe_products FOR oe.products;\n\nDECLARE\n   l_product_name oe_products.product_name%TYPE;\n   co_price CONSTANT oe_products.list_price%TYPE := 1000;\nBEGIN\n   SELECT p.product_name\n     INTO l_product_name\n     FROM oe_products p\n    WHERE list_price > co_price;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN\n      NULL; -- handle_no_data_found;\n   WHEN TOO_MANY_ROWS THEN\n      NULL; -- handle_too_many_rows;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/",
            "text": "G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit.\n\n\n\n\nMinor\n\n\nMaintainability, Reliability, Reusability, Testability\n\n\n\n\nReason\n\n\nThis technique raises an error (value_error) which may not be handled in the called program unit. This is the right way to do it, as the error is not within this unit but when calling it, so the caller should handle the error.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION dept_by_name (in_dept_name IN departments.department_name%TYPE)\n      RETURN departments%ROWTYPE IS\n      l_return departments%rowtype;\n   BEGIN\n       IF    in_dept_name IS NULL \n          OR LENGTH(in_dept_name) > 20\n       THEN\n          RAISE err.e_param_to_large;\n       END IF;\n       -- get the department by name\n       SELECT *\n         FROM departments\n        WHERE department_name = in_dept_name;\n\n       RETURN l_return;\n   END dept_by_name;\nEND department_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION dept_by_name (in_dept_name IN departments.department_name%TYPE)\n      RETURN departments%ROWTYPE IS\n      l_dept_name departments.department_name%TYPE NOT NULL := in_dept_name;\n      l_return departments%rowtype;\n   BEGIN\n       -- get the department by name\n       SELECT *\n         FROM departments\n        WHERE department_name = l_dept_name;\n\n       RETURN l_return;\n   END dept_by_name;\nEND department_api;\n/\n\n\n\n\nFunction call\n\n\n...\n   r_deparment := department_api.dept_by_name('Far to long name of a department');\n...\nEXCEPTION\n   WHEN VALUE_ERROR THEN ...",
            "title": "G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit."
        },
        {
            "location": "/4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#g-8310-always-validate-input-parameter-size-by-assigning-the-parameter-to-a-size-limited-variable-in-the-declaration-section-of-program-unit",
            "text": "Minor  Maintainability, Reliability, Reusability, Testability",
            "title": "G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit."
        },
        {
            "location": "/4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#reason",
            "text": "This technique raises an error (value_error) which may not be handled in the called program unit. This is the right way to do it, as the error is not within this unit but when calling it, so the caller should handle the error.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION dept_by_name (in_dept_name IN departments.department_name%TYPE)\n      RETURN departments%ROWTYPE IS\n      l_return departments%rowtype;\n   BEGIN\n       IF    in_dept_name IS NULL \n          OR LENGTH(in_dept_name) > 20\n       THEN\n          RAISE err.e_param_to_large;\n       END IF;\n       -- get the department by name\n       SELECT *\n         FROM departments\n        WHERE department_name = in_dept_name;\n\n       RETURN l_return;\n   END dept_by_name;\nEND department_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY department_api IS\n   FUNCTION dept_by_name (in_dept_name IN departments.department_name%TYPE)\n      RETURN departments%ROWTYPE IS\n      l_dept_name departments.department_name%TYPE NOT NULL := in_dept_name;\n      l_return departments%rowtype;\n   BEGIN\n       -- get the department by name\n       SELECT *\n         FROM departments\n        WHERE department_name = l_dept_name;\n\n       RETURN l_return;\n   END dept_by_name;\nEND department_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#function-call",
            "text": "...\n   r_deparment := department_api.dept_by_name('Far to long name of a department');\n...\nEXCEPTION\n   WHEN VALUE_ERROR THEN ...",
            "title": "Function call"
        },
        {
            "location": "/4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/",
            "text": "G-8410: Always use application locks to ensure a program unit only running once at a given time.\n\n\n\n\nMinor\n\n\nEfficiency, Reliability\n\n\n\n\nReason\n\n\nThis technique allows us to have locks across transactions as well as a proven way to clean up at the end of the session.\n\n\nThe alternative using a table where a \u201cLock-Row\u201d is stored has the disadvantage that in case of an error a proper cleanup has to be done to \u201cunlock\u201d the program unit.\n\n\nExample (bad)\n\n\n-- create locking table\nCREATE TABLE application_locks (\n   lock_name VARCHAR2(128 CHAR) NOT NULL PRIMARY KEY\n  ,lock_time TIMESTAMP          NOT NULL\n) ORGANIZATION INDEX;\n-- definition\nCREATE OR REPLACE PACKAGE BODY lock_up IS\n   PROCEDURE request_lock (in_lock_name IN VARCHAR2) IS\n      PRAGMA AUTONOMOUS_TRANSACTION;\n   BEGIN\n      INSERT INTO application_locks (lock_name, lock_time) VALUES (in_lock_name, systimestamp);\n      COMMIT;\n   EXCEPTION\n      WHEN DUP_VAL_ON_INDEX THEN\n         RAISE err.e_lock_request_failed;\n   END request_lock;\n\n   PROCEDURE release_lock (in_lock_name IN VARCHAR2) IS\n      PRAGMA AUTONOMOUS_TRANSACTION;\n   BEGIN\n      DELETE FROM application_locks\n       WHERE lock_name = in_lock_name;\n      COMMIT;\n   END release_lock;\nEND lock_up;\n/\n-- call\nDECLARE\n   co_lock_name CONSTANT VARCHAR2(30 CHAR) := 'APPLICATION_LOCK';\nBEGIN\n   lock_up.request_lock(in_lock_name => co_lock_name);\n   -- processing\n   lock_up.release_lock(in_lock_name => co_lock_name);\nEXCEPTION\n   WHEN OTHERS THEN\n      -- log error\n      lock_up.release_lock(in_lock_name => co_lock_name);\n      RAISE;\nEND;\n/\n\n\n\n\nExample (good)\n\n\n-- definition\nCREATE OR REPLACE PACKAGE BODY lock_up IS\n   FUNCTION request_lock (in_lock_name         IN VARCHAR2\n                         ,in_release_on_commit IN BOOLEAN := FALSE) RETURN VARCHAR2 IS\n      l_lock_handle VARCHAR2(128 CHAR);\n   BEGIN\n      SYS.DBMS_LOCK.ALLOCATE_UNIQUE (lockname        => in_lock_name\n                                    ,lockhandle      => l_lock_handle\n                                    ,expiration_secs => constants_up.co_one_week); \n\n      IF sys.DBMS_LOCK.REQUEST(lockhandle        => l_lock_handle\n                              ,lockmode          => sys.DBMS_LOCK.X_MODE\n                              ,TIMEOUT           => sys.DBMS_LOCK.MAXWAIT\n                              ,release_on_commit => COALESCE(in_release_on_commit\n                                                            ,FALSE)) > 0 THEN\n         RAISE err.e_lock_request_failed;\n      END IF;\n\n      RETURN l_lock_handle;\n   END request_lock;\n\n   PROCEDURE release_lock (in_lock_handle IN VARCHAR2) IS\n   BEGIN\n     IF sys.DBMS_LOCK.RELEASE(lockhandle => in_lock_handle) > 0 THEN\n         RAISE err.e_lock_request_failed;\n     END IF;\n   END release_lock;\nEND lock_up;\n/\n-- call\nDECLARE\n   l_handle VARCHAR2(128 CHAR);\n   co_lock_name CONSTANT VARCHAR2(30 CHAR) := 'APPLICATION_LOCK';\nBEGIN\n   l_handle := lock_up.request_lock(in_lock_name => co_lock_name);\n   -- processing\n   lock_up.release_lock(in_lock_handle => l_handle);\nEXCEPTION\n   WHEN OTHERS THEN\n      -- log error\n      lock_up.release_lock(in_lock_handle => l_handle);\n      RAISE;\nEND;\n/",
            "title": "G-8410: Always use application locks to ensure a program unit only running once at a given time."
        },
        {
            "location": "/4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#g-8410-always-use-application-locks-to-ensure-a-program-unit-only-running-once-at-a-given-time",
            "text": "Minor  Efficiency, Reliability",
            "title": "G-8410: Always use application locks to ensure a program unit only running once at a given time."
        },
        {
            "location": "/4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#reason",
            "text": "This technique allows us to have locks across transactions as well as a proven way to clean up at the end of the session.  The alternative using a table where a \u201cLock-Row\u201d is stored has the disadvantage that in case of an error a proper cleanup has to be done to \u201cunlock\u201d the program unit.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#example-bad",
            "text": "-- create locking table\nCREATE TABLE application_locks (\n   lock_name VARCHAR2(128 CHAR) NOT NULL PRIMARY KEY\n  ,lock_time TIMESTAMP          NOT NULL\n) ORGANIZATION INDEX;\n-- definition\nCREATE OR REPLACE PACKAGE BODY lock_up IS\n   PROCEDURE request_lock (in_lock_name IN VARCHAR2) IS\n      PRAGMA AUTONOMOUS_TRANSACTION;\n   BEGIN\n      INSERT INTO application_locks (lock_name, lock_time) VALUES (in_lock_name, systimestamp);\n      COMMIT;\n   EXCEPTION\n      WHEN DUP_VAL_ON_INDEX THEN\n         RAISE err.e_lock_request_failed;\n   END request_lock;\n\n   PROCEDURE release_lock (in_lock_name IN VARCHAR2) IS\n      PRAGMA AUTONOMOUS_TRANSACTION;\n   BEGIN\n      DELETE FROM application_locks\n       WHERE lock_name = in_lock_name;\n      COMMIT;\n   END release_lock;\nEND lock_up;\n/\n-- call\nDECLARE\n   co_lock_name CONSTANT VARCHAR2(30 CHAR) := 'APPLICATION_LOCK';\nBEGIN\n   lock_up.request_lock(in_lock_name => co_lock_name);\n   -- processing\n   lock_up.release_lock(in_lock_name => co_lock_name);\nEXCEPTION\n   WHEN OTHERS THEN\n      -- log error\n      lock_up.release_lock(in_lock_name => co_lock_name);\n      RAISE;\nEND;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#example-good",
            "text": "-- definition\nCREATE OR REPLACE PACKAGE BODY lock_up IS\n   FUNCTION request_lock (in_lock_name         IN VARCHAR2\n                         ,in_release_on_commit IN BOOLEAN := FALSE) RETURN VARCHAR2 IS\n      l_lock_handle VARCHAR2(128 CHAR);\n   BEGIN\n      SYS.DBMS_LOCK.ALLOCATE_UNIQUE (lockname        => in_lock_name\n                                    ,lockhandle      => l_lock_handle\n                                    ,expiration_secs => constants_up.co_one_week); \n\n      IF sys.DBMS_LOCK.REQUEST(lockhandle        => l_lock_handle\n                              ,lockmode          => sys.DBMS_LOCK.X_MODE\n                              ,TIMEOUT           => sys.DBMS_LOCK.MAXWAIT\n                              ,release_on_commit => COALESCE(in_release_on_commit\n                                                            ,FALSE)) > 0 THEN\n         RAISE err.e_lock_request_failed;\n      END IF;\n\n      RETURN l_lock_handle;\n   END request_lock;\n\n   PROCEDURE release_lock (in_lock_handle IN VARCHAR2) IS\n   BEGIN\n     IF sys.DBMS_LOCK.RELEASE(lockhandle => in_lock_handle) > 0 THEN\n         RAISE err.e_lock_request_failed;\n     END IF;\n   END release_lock;\nEND lock_up;\n/\n-- call\nDECLARE\n   l_handle VARCHAR2(128 CHAR);\n   co_lock_name CONSTANT VARCHAR2(30 CHAR) := 'APPLICATION_LOCK';\nBEGIN\n   l_handle := lock_up.request_lock(in_lock_name => co_lock_name);\n   -- processing\n   lock_up.release_lock(in_lock_handle => l_handle);\nEXCEPTION\n   WHEN OTHERS THEN\n      -- log error\n      lock_up.release_lock(in_lock_handle => l_handle);\n      RAISE;\nEND;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/",
            "text": "G-8510: Always use dbms_application_info to track program process transiently.\n\n\n\n\nMinor\n\n\nEfficiency, Reliability\n\n\n\n\nReason\n\n\nThis technique allows us to view progress of a process without having to persistently write log data in either a table or a file. The information is accessible trough \nV$SESSION\n view.\n\n\nExample (bad)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE process_emps IS\n   BEGIN\n      <<employees>>\n      FOR emp_rec IN (SELECT employee_id\n                        FROM employees\n                       ORDER BY employee_id)\n      LOOP\n         NULL; -- some processing\n      END LOOP employees;\n   END process_emps;\nEND employee_api;\n/\n\n\n\n\nExample (good)\n\n\nCREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE process_emps IS\n   BEGIN\n      SYS.DBMS_APPLICATION_INFO.SET_MODULE(module_name => $$PLSQL_UNIT\n                                          ,action_name => 'Init');\n      <<employees>>\n      FOR emp_rec IN (SELECT employee_id \n                        FROM employees\n                       ORDER BY employee_id)\n      LOOP\n         SYS.DBMS_APPLICATION_INFO.SET_ACTION('Processing ' || emp_rec.employee_id);\n      END LOOP employees;\n   end process_emps;\nEND employee_api;\n/",
            "title": "G-8510: Always use dbms_application_info to track program process transiently."
        },
        {
            "location": "/4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#g-8510-always-use-dbms_application_info-to-track-program-process-transiently",
            "text": "Minor  Efficiency, Reliability",
            "title": "G-8510: Always use dbms_application_info to track program process transiently."
        },
        {
            "location": "/4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#reason",
            "text": "This technique allows us to view progress of a process without having to persistently write log data in either a table or a file. The information is accessible trough  V$SESSION  view.",
            "title": "Reason"
        },
        {
            "location": "/4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#example-bad",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE process_emps IS\n   BEGIN\n      <<employees>>\n      FOR emp_rec IN (SELECT employee_id\n                        FROM employees\n                       ORDER BY employee_id)\n      LOOP\n         NULL; -- some processing\n      END LOOP employees;\n   END process_emps;\nEND employee_api;\n/",
            "title": "Example (bad)"
        },
        {
            "location": "/4-language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#example-good",
            "text": "CREATE OR REPLACE PACKAGE BODY employee_api IS\n   PROCEDURE process_emps IS\n   BEGIN\n      SYS.DBMS_APPLICATION_INFO.SET_MODULE(module_name => $$PLSQL_UNIT\n                                          ,action_name => 'Init');\n      <<employees>>\n      FOR emp_rec IN (SELECT employee_id \n                        FROM employees\n                       ORDER BY employee_id)\n      LOOP\n         SYS.DBMS_APPLICATION_INFO.SET_ACTION('Processing ' || emp_rec.employee_id);\n      END LOOP employees;\n   end process_emps;\nEND employee_api;\n/",
            "title": "Example (good)"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/",
            "text": "Complexity Analysis\n\n\nUsing software metrics like complexity analysis will guide you towards maintainable and testable pieces of code by reducing the complexity and splitting the code into smaller chunks.\n\n\nHalstead Metrics\n\n\nCalculation\n\n\nFirst, we need to compute the following numbers, given the program:\n\n\n\n\nn_1\nn_1\n = the number of distinct operators\n\n\nn_2\nn_2\n = the number of distinct operands\n\n\nN_1\nN_1\n = the total number of operators\n\n\nN_2\nN_2\n = the total number of operands\n\n\n\n\nFrom these numbers, five measures can be calculated:\n\n\n\n\nProgram length: \nN = N_1 + N_2\nN = N_1 + N_2\n\n\nProgram vocabulary: \nn = n_1 + n_2\nn = n_1 + n_2\n\n\nVolume: \nV = N \\cdot log_2 n\nV = N \\cdot log_2 n\n\n\nDifficulty: \nD = \\frac{n_1}{2} \\cdot \\frac{N_2}{n_2}\nD = \\frac{n_1}{2} \\cdot \\frac{N_2}{n_2}\n\n\nEffort: \nE = D \\cdot V\nE = D \\cdot V\n\n\n\n\nThe difficulty measure \nD\nD\n is related to the difficulty of the program to write or understand, e.g. when doing code review.\n\n\nThe volume measure \nV\nV\n describes the size of the implementation of an algorithm.\n\n\nMcCabe's Cyclomatic Complexity\n\n\nDescription\n\n\nCyclomatic complexity (or conditional complexity) is a software metric used to measure the complexity of a program. It directly measures the number of linearly independent paths through a program's source code. \n\n\nCyclomatic complexity is computed using the control flow graph of the program: the nodes of the graph correspond to indivisible groups of commands of a program, and a directed edge connects two nodes if the second command might be executed immediately after the first command. Cyclomatic complexity may also be applied to individual functions, modules, methods or classes within a program.\n\n\nThe cyclomatic complexity of a section of source code is the count of the number of linearly independent paths through the source code. For instance, if the source code contains no decision points, such as IF statements or FOR loops, the complexity would be 1, since there is only a single path through the code. If the code has a single IF statement containing a single condition there would be two paths through the code, one path where the IF statement is evaluated as TRUE and one path where the IF statement is evaluated as FALSE.\n\n\nCalculation\n\n\nMathematically, the cyclomatic complexity of a structured program is defined with reference to a directed graph containing the basic blocks of the program, with an edge between two basic blocks if control may pass from the first to the second (the control flow graph of the program). The complexity is then defined as: \n\n\n\n\nM = E - N + 2P\n\n\nM = E - N + 2P\n\n\n\n\nwhere\n\n\n\n\nM\nM\n = cyclomatic complexity\n\n\nE\nE\n = the number of edges of the graph\n\n\nN\nN\n = the number of nodes of the graph\n\n\nP\nP\n = the number of connected components.\n\n\n\n\n\n\n\n\nTake, for example, a control flow graph of a simple program. The program begins executing at the red node, then enters a loop (group of three nodes immediately below the red node). On exiting the loop, there is a conditional statement (group below the loop), and finally the program exits at the blue node. For this graph, \nE = 9\nE = 9\n, \nN = 8\nN = 8\n and \nP = 1\nP = 1\n, so the cyclomatic complexity of the program is \n3\n3\n.\n\n\nBEGIN\n   FOR i IN 1..3\n   LOOP\n      dbms_output.put_line('in loop');\n   END LOOP;\n   --\n   IF 1 = 1\n   THEN\n      dbms_output.put_line('yes');\n   END IF;\n   --\n   dbms_output.put_line('end');\nEND;\n/\n\n\n\n\nFor a single program (or subroutine or method), P is always equal to 1. Cyclomatic complexity may, however, be applied to several such programs or subprograms at the same time (e.g., to all of the methods in a class), and in these cases P will be equal to the number of programs in question, as each subprogram will appear as a disconnected subset of the graph.\n\n\nIt can be shown that the cyclomatic complexity of any structured program with only one entrance point and one exit point is equal to the number of decision points (i.e., 'if' statements or conditional loops) contained in that program plus one.\n\n\nCyclomatic complexity may be extended to a program with multiple exit points; in this case it is equal to: \n\n\n\n\n\\pi = s + 2\n\n\n\\pi = s + 2\n\n\n\n\nWhere \n\n\n\n\n\\pi\n\\pi\n is the number of decision points in the program, and \n\n\ns\ns\n is the number of exit points.",
            "title": "Complexity Analysis"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/#complexity-analysis",
            "text": "Using software metrics like complexity analysis will guide you towards maintainable and testable pieces of code by reducing the complexity and splitting the code into smaller chunks.",
            "title": "Complexity Analysis"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/#halstead-metrics",
            "text": "",
            "title": "Halstead Metrics"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/#calculation",
            "text": "First, we need to compute the following numbers, given the program:   n_1 n_1  = the number of distinct operators  n_2 n_2  = the number of distinct operands  N_1 N_1  = the total number of operators  N_2 N_2  = the total number of operands   From these numbers, five measures can be calculated:   Program length:  N = N_1 + N_2 N = N_1 + N_2  Program vocabulary:  n = n_1 + n_2 n = n_1 + n_2  Volume:  V = N \\cdot log_2 n V = N \\cdot log_2 n  Difficulty:  D = \\frac{n_1}{2} \\cdot \\frac{N_2}{n_2} D = \\frac{n_1}{2} \\cdot \\frac{N_2}{n_2}  Effort:  E = D \\cdot V E = D \\cdot V   The difficulty measure  D D  is related to the difficulty of the program to write or understand, e.g. when doing code review.  The volume measure  V V  describes the size of the implementation of an algorithm.",
            "title": "Calculation"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/#mccabes-cyclomatic-complexity",
            "text": "",
            "title": "McCabe's Cyclomatic Complexity"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/#description",
            "text": "Cyclomatic complexity (or conditional complexity) is a software metric used to measure the complexity of a program. It directly measures the number of linearly independent paths through a program's source code.   Cyclomatic complexity is computed using the control flow graph of the program: the nodes of the graph correspond to indivisible groups of commands of a program, and a directed edge connects two nodes if the second command might be executed immediately after the first command. Cyclomatic complexity may also be applied to individual functions, modules, methods or classes within a program.  The cyclomatic complexity of a section of source code is the count of the number of linearly independent paths through the source code. For instance, if the source code contains no decision points, such as IF statements or FOR loops, the complexity would be 1, since there is only a single path through the code. If the code has a single IF statement containing a single condition there would be two paths through the code, one path where the IF statement is evaluated as TRUE and one path where the IF statement is evaluated as FALSE.",
            "title": "Description"
        },
        {
            "location": "/5-complexity-analysis/complexity-analysis/#calculation_1",
            "text": "Mathematically, the cyclomatic complexity of a structured program is defined with reference to a directed graph containing the basic blocks of the program, with an edge between two basic blocks if control may pass from the first to the second (the control flow graph of the program). The complexity is then defined as:    M = E - N + 2P  M = E - N + 2P   where   M M  = cyclomatic complexity  E E  = the number of edges of the graph  N N  = the number of nodes of the graph  P P  = the number of connected components.     Take, for example, a control flow graph of a simple program. The program begins executing at the red node, then enters a loop (group of three nodes immediately below the red node). On exiting the loop, there is a conditional statement (group below the loop), and finally the program exits at the blue node. For this graph,  E = 9 E = 9 ,  N = 8 N = 8  and  P = 1 P = 1 , so the cyclomatic complexity of the program is  3 3 .  BEGIN\n   FOR i IN 1..3\n   LOOP\n      dbms_output.put_line('in loop');\n   END LOOP;\n   --\n   IF 1 = 1\n   THEN\n      dbms_output.put_line('yes');\n   END IF;\n   --\n   dbms_output.put_line('end');\nEND;\n/  For a single program (or subroutine or method), P is always equal to 1. Cyclomatic complexity may, however, be applied to several such programs or subprograms at the same time (e.g., to all of the methods in a class), and in these cases P will be equal to the number of programs in question, as each subprogram will appear as a disconnected subset of the graph.  It can be shown that the cyclomatic complexity of any structured program with only one entrance point and one exit point is equal to the number of decision points (i.e., 'if' statements or conditional loops) contained in that program plus one.  Cyclomatic complexity may be extended to a program with multiple exit points; in this case it is equal to:    \\pi = s + 2  \\pi = s + 2   Where    \\pi \\pi  is the number of decision points in the program, and   s s  is the number of exit points.",
            "title": "Calculation"
        },
        {
            "location": "/6-code-reviews/code-reviews/",
            "text": "Code Reviews\n\n\nCode reviews check the results of software engineering. According to IEEE-Norm 729, a review is a more or less planned and structured analysis and evaluation process. Here we distinguish between code review and architect review. \n\n\nTo perform a code review means that after or during the development one or more reviewer proof-reads the code to find potential errors, potential areas for simplification, or test cases. A code review is a very good opportunity to save costs by fixing issues before the testing phase.\n\n\nWhat can a code-review be good for?\n\n\n\n\nCode quality\n\n\nCode clarity and maintainability\n\n\nQuality of the overall architecture\n\n\nQuality of the documentation\n\n\nQuality of the interface specification\n\n\n\n\nFor an effective review, the following factors must be considered:\n\n\n\n\nDefinition of clear goals.\n\n\nChoice of a suitable person with constructive critical faculties.\n\n\nPsychological aspects.\n\n\nSelection of the right review techniques.\n\n\nSupport of the review process from the management.\n\n\nExistence of a culture of learning and process optimization. \n\n\n\n\nRequirements for the reviewer: \n\n\n\n\nHe must not be the owner of the code.\n\n\nCode reviews may be unpleasant for the developer, as he could fear that his code will be criticized. If the critic is not considerate, the code writer will build up rejection and resistance against code reviews.",
            "title": "Code Reviews"
        },
        {
            "location": "/6-code-reviews/code-reviews/#code-reviews",
            "text": "Code reviews check the results of software engineering. According to IEEE-Norm 729, a review is a more or less planned and structured analysis and evaluation process. Here we distinguish between code review and architect review.   To perform a code review means that after or during the development one or more reviewer proof-reads the code to find potential errors, potential areas for simplification, or test cases. A code review is a very good opportunity to save costs by fixing issues before the testing phase.  What can a code-review be good for?   Code quality  Code clarity and maintainability  Quality of the overall architecture  Quality of the documentation  Quality of the interface specification   For an effective review, the following factors must be considered:   Definition of clear goals.  Choice of a suitable person with constructive critical faculties.  Psychological aspects.  Selection of the right review techniques.  Support of the review process from the management.  Existence of a culture of learning and process optimization.    Requirements for the reviewer:    He must not be the owner of the code.  Code reviews may be unpleasant for the developer, as he could fear that his code will be criticized. If the critic is not considerate, the code writer will build up rejection and resistance against code reviews.",
            "title": "Code Reviews"
        },
        {
            "location": "/7-tool-support/tool-support/",
            "text": "Tool Support\n\n\nDevelopment\n\n\nTrivadis offers a cost-free extension to ORACLE SQL Developer to test compliance with this coding guideline. The extension may be parameterized to your preferred set of rules and allows checking this set against a program unit.\n\n\nSetting the preferences\n\n\n\n\nThere is an include list as well as an exclude list to define which rules to be checked or ignored.\n\n\nActivate PLSQL Cop using context menu\n\n\n\n\nThe result of the ckecking process is a list of violations with direct links to the place in the code as well as software metrics like:\n\n\n\n\nCyclomatic complexity\n\n\nHalstead volume\n\n\nMaintainability Index\n\n\nNumber of lines of code\n\n\nNumber of comment lines\n\n\nIssue Overview\n\n\n\n\nThis statistics are gathered for each program unit in the reviewed code.\n\n\nSoftware metrics",
            "title": "Tool Support"
        },
        {
            "location": "/7-tool-support/tool-support/#tool-support",
            "text": "",
            "title": "Tool Support"
        },
        {
            "location": "/7-tool-support/tool-support/#development",
            "text": "Trivadis offers a cost-free extension to ORACLE SQL Developer to test compliance with this coding guideline. The extension may be parameterized to your preferred set of rules and allows checking this set against a program unit.",
            "title": "Development"
        },
        {
            "location": "/7-tool-support/tool-support/#setting-the-preferences",
            "text": "There is an include list as well as an exclude list to define which rules to be checked or ignored.",
            "title": "Setting the preferences"
        },
        {
            "location": "/7-tool-support/tool-support/#activate-plsql-cop-using-context-menu",
            "text": "The result of the ckecking process is a list of violations with direct links to the place in the code as well as software metrics like:   Cyclomatic complexity  Halstead volume  Maintainability Index  Number of lines of code  Number of comment lines  Issue Overview   This statistics are gathered for each program unit in the reviewed code.",
            "title": "Activate PLSQL Cop using context menu"
        },
        {
            "location": "/7-tool-support/tool-support/#software-metrics",
            "text": "",
            "title": "Software metrics"
        },
        {
            "location": "/9-appendix/appendix/",
            "text": "Appendix\n\n\nA - Mapping new guidelines to prior versions\n\n\n\n\n\n\n\n\nOld Id\n\n\nNew Id\n\n\nText\n\n\nSeverity\n\n\nChange-ability\n\n\nEfficiency\n\n\nMaintain-ability\n\n\nPortability\n\n\nReliability\n\n\nReusability\n\n\nSecurity\n\n\nTestability\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1010\n\n\nTry to label your sub blocks.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n1020\n\n\nAlways have a matching loop or block label.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n1030\n\n\nAvoid defining variables that are not used.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n1040\n\n\nAvoid dead code.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n1050\n\n\nAvoid using literals in your code.\n\n\nMinor\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6\n\n\n1060\n\n\nAvoid storing ROWIDs or UROWIDs in database tables.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n7\n\n\n1070\n\n\nAvoid nesting comment blocks.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8\n\n\n2110\n\n\nTry to use anchored declarations for variables, constants and types.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n9\n\n\n2120\n\n\nTry to have a single location to define your types.\n\n\nMinor\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n2130\n\n\nTry to use subtypes for constructs used often in your code.\n\n\nMinor\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11\n\n\n2140\n\n\nNever initialize variables with NULL.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n12\n\n\n2150\n\n\nAvoid comparisons with NULL value, consider using IS [NOT] NULL.\n\n\nBlocker\n\n\n\n\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n13\n\n\n2160\n\n\nAvoid initializing variables using functions in the declaration section.\n\n\nCritical\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n14\n\n\n2170\n\n\nNever overload variables.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n15\n\n\n2180\n\n\nNever use quoted identifiers.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n16\n\n\n2185\n\n\nAvoid using overly short names for explicitly or implicitly declared identifiers.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17\n\n\n2190\n\n\nAvoid the use of ROWID or UROWID.\n\n\nMajor\n\n\n\n\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n18\n\n\n2210\n\n\nAvoid declaring NUMBER variables or subtypes with no precision.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n19\n\n\n2220\n\n\nTry to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n2230\n\n\nTry to use SIMPLE_INTEGER datatype when appropriate.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n20\n\n\n2310\n\n\nAvoid using CHAR data type.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n21\n\n\n2320\n\n\nAvoid using VARCHAR data type.\n\n\nMajor\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n22\n\n\n2330\n\n\nNever use zero-length strings to substitute NULL.\n\n\nMajor\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n23\n\n\n2340\n\n\nAlways define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored).\n\n\nMinor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n24\n\n\n2410\n\n\nTry to use boolean data type for values with dual meaning.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n25\n\n\n2510\n\n\nAvoid using the LONG and LONG RAW data types.\n\n\nMajor\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n26\n\n\n3110\n\n\nAlways specify the target columns when coding an insert statement.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n27\n\n\n3120\n\n\nAlways use table aliases when your SQL statement involves more than one source.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n28\n\n\n3130\n\n\nTry to use ANSI SQL-92 join syntax.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n29\n\n\n3140\n\n\nTry to use anchored records as targets for your cursors.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n3150\n\n\nTry to use identity columns for surrogate keys.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n3160\n\n\nAvoid virtual columns to be visible.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n3170\n\n\nAlways use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n3180\n\n\nAlways specify column names instead of positional references in ORDER BY clauses.\n\n\nMajor\n\n\n\u2718\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n3190\n\n\nAvoid using NATURAL JOIN.\n\n\nMajor\n\n\n\u2718\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n30\n\n\n3210\n\n\nAlways use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement more than 4 times.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n31\n\n\n4110\n\n\nAlways use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n32\n\n\n4120\n\n\nAvoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause.\n\n\nCritical\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n33\n\n\n4130\n\n\nAlways close locally opened cursors.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n34\n\n\n4140\n\n\nAvoid executing any statements between a SQL operation and the usage of an implicit cursor attribute.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n35\n\n\n4210\n\n\nTry to use CASE rather than an IF statement with multiple ELSIF paths.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n36\n\n\n4220\n\n\nTry to use CASE rather than DECODE.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n37\n\n\n4230\n\n\nAlways use COALESCE instead of NVL, if parameter 2 of the NVL function is a function call or a SELECT statement.\n\n\nCritical\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n38\n\n\n4240\n\n\nAlways use CASE instead of NVL2 if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement.\n\n\nCritical\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n39\n\n\n4310\n\n\nNever use GOTO statements in your code.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n40\n\n\n4320\n\n\nAlways label your loops.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n41\n\n\n4330\n\n\nAlways use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n42\n\n\n4340\n\n\nAlways use a NUMERIC FOR loop to process a dense array.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n43\n\n\n4350\n\n\nAlways use 1 as lower and COUNT() as upper bound when looping through a dense array.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n44\n\n\n4360\n\n\nAlways use a WHILE loop to process a loose array.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n45\n\n\n4370\n\n\nAvoid using EXIT to stop loop processing unless you are in a basic loop.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n46\n\n\n4375\n\n\nAlways use EXIT WHEN instead of an IF statement to exit from a loop.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n47\n\n\n4380\n\n\nTry to label your EXIT WHEN statements.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n48\n\n\n4385\n\n\nNever use a cursor for loop to check whether a cursor returns data.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n49\n\n\n4390\n\n\nAvoid use of unreferenced FOR loop indexes.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n50\n\n\n4395\n\n\nAvoid hard-coded upper or lower bound values with FOR loops.\n\n\nMinor\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n5010\n\n\nTry to use a error/logging framework for your application.\n\n\nCritical\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n51\n\n\n5020\n\n\nNever handle unnamed exceptions using the error number.\n\n\nCritical\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n52\n\n\n5030\n\n\nNever assign predefined exception names to user defined exceptions.\n\n\nBlocker\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n53\n\n\n5040\n\n\nAvoid use of WHEN OTHERS clause in an exception section without any other specific handlers.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n54\n\n\nn/a\n\n\nAvoid use of EXCEPTION_INIT pragma for a  20nnn error.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n55\n\n\n5050\n\n\nAvoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded  20nnn error number or hard-coded message.\n\n\nMajor\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n56\n\n\n5060\n\n\nAvoid unhandled exceptions\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n57\n\n\n5070\n\n\nAvoid using Oracle predefined exceptions\n\n\nCritical\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n58\n\n\n6010\n\n\nAlways use a character variable to execute dynamic SQL.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n59\n\n\n6020\n\n\nTry to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n60\n\n\n7110\n\n\nTry to use named notation when calling program units.\n\n\nMajor\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n61\n\n\n7120\n\n\nAlways add the name of the program unit to its end keyword.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n62\n\n\n7130\n\n\nAlways use parameters or pull in definitions rather than referencing external variables in a local program unit.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n63\n\n\n7140\n\n\nAlways ensure that locally defined procedures or functions are referenced.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n64\n\n\n7150\n\n\nTry to remove unused parameters.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n65\n\n\n7210\n\n\nTry to keep your packages small. Include only few procedures and functions that are used in the same context.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n66\n\n\n7220\n\n\nAlways use forward declaration for private functions and procedures.\n\n\nMinor\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n67\n\n\n7230\n\n\nAvoid declaring global variables public.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n68\n\n\n7240\n\n\nAvoid using an IN OUT parameter as IN or OUT only.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n69\n\n\n7310\n\n\nAvoid standalone procedures \u2013 put your procedures in packages.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n70\n\n\n7320\n\n\nAvoid using RETURN statements in a PROCEDURE.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n71\n\n\n7410\n\n\nAvoid standalone functions \u2013 put your functions in packages.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n73\n\n\n7420\n\n\nAlways make the RETURN statement the last statement of your function.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n72\n\n\n7430\n\n\nTry to use no more than one RETURN statement within a function.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n74\n\n\n7440\n\n\nNever use OUT parameters to return values from a function.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n75\n\n\n7450\n\n\nNever return a NULL value from a BOOLEAN function.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\nn/a\n\n\n7460\n\n\nTry to define your packaged/standalone function to be deterministic if appropriate.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n76\n\n\n7510\n\n\nAlways prefix ORACLE supplied packages with owner schema name.\n\n\nMajor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n77\n\n\n7710\n\n\nAvoid cascading triggers.\n\n\nMajor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\nn/a\n\n\n7810\n\n\nDo not use SQL inside PL/SQL to read sequence numbers (or SYSDATE)\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n78\n\n\n8110\n\n\nNever use SELECT COUNT(*) if you are only interested in the existence of a row.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n8120\n\n\nNever check existence of a row to decide whether to create it or not.\n\n\nMajor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n79\n\n\n8210\n\n\nAlways use synonyms when accessing objects of another application schema.\n\n\nMajor\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n8310\n\n\nAlways validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit.\n\n\nMinor\n\n\n\n\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\u2718\n\n\n\n\n\u2718\n\n\n\n\n\n\nn/a\n\n\n8410\n\n\nAlways use application locks to ensure a program unit only running once at a given time.\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718\n\n\n\n\n\n\n\n\n\n\n\n\nn/a\n\n\n8510\n\n\nAlways use dbms_application_info to track program process transiently\n\n\nMinor\n\n\n\n\n\u2718\n\n\n\n\n\n\n\u2718",
            "title": "Appendix"
        },
        {
            "location": "/9-appendix/appendix/#appendix",
            "text": "",
            "title": "Appendix"
        },
        {
            "location": "/9-appendix/appendix/#a-mapping-new-guidelines-to-prior-versions",
            "text": "Old Id  New Id  Text  Severity  Change-ability  Efficiency  Maintain-ability  Portability  Reliability  Reusability  Security  Testability      1  1010  Try to label your sub blocks.  Minor    \u2718         2  1020  Always have a matching loop or block label.  Minor    \u2718         3  1030  Avoid defining variables that are not used.  Minor   \u2718  \u2718         4  1040  Avoid dead code.  Minor    \u2718         5  1050  Avoid using literals in your code.  Minor  \u2718           6  1060  Avoid storing ROWIDs or UROWIDs in database tables.  Major      \u2718       7  1070  Avoid nesting comment blocks.  Minor    \u2718         8  2110  Try to use anchored declarations for variables, constants and types.  Major    \u2718   \u2718       9  2120  Try to have a single location to define your types.  Minor  \u2718           10  2130  Try to use subtypes for constructs used often in your code.  Minor  \u2718           11  2140  Never initialize variables with NULL.  Minor    \u2718         12  2150  Avoid comparisons with NULL value, consider using IS [NOT] NULL.  Blocker     \u2718  \u2718       13  2160  Avoid initializing variables using functions in the declaration section.  Critical      \u2718       14  2170  Never overload variables.  Major      \u2718       15  2180  Never use quoted identifiers.  Major    \u2718         16  2185  Avoid using overly short names for explicitly or implicitly declared identifiers.  Minor    \u2718         17  2190  Avoid the use of ROWID or UROWID.  Major     \u2718  \u2718       18  2210  Avoid declaring NUMBER variables or subtypes with no precision.  Minor   \u2718          19  2220  Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values.  Minor   \u2718          n/a  2230  Try to use SIMPLE_INTEGER datatype when appropriate.  Minor   \u2718          20  2310  Avoid using CHAR data type.  Major      \u2718       21  2320  Avoid using VARCHAR data type.  Major     \u2718        22  2330  Never use zero-length strings to substitute NULL.  Major     \u2718        23  2340  Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored).  Minor      \u2718       24  2410  Try to use boolean data type for values with dual meaning.  Minor    \u2718         25  2510  Avoid using the LONG and LONG RAW data types.  Major     \u2718        26  3110  Always specify the target columns when coding an insert statement.  Major    \u2718   \u2718       27  3120  Always use table aliases when your SQL statement involves more than one source.  Major    \u2718         28  3130  Try to use ANSI SQL-92 join syntax.  Minor    \u2718  \u2718        29  3140  Try to use anchored records as targets for your cursors.  Major    \u2718   \u2718       n/a  3150  Try to use identity columns for surrogate keys.  Minor    \u2718   \u2718       n/a  3160  Avoid virtual columns to be visible.  Major    \u2718   \u2718       n/a  3170  Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values.  Major      \u2718       n/a  3180  Always specify column names instead of positional references in ORDER BY clauses.  Major  \u2718     \u2718       n/a  3190  Avoid using NATURAL JOIN.  Major  \u2718     \u2718       30  3210  Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement more than 4 times.  Major   \u2718          31  4110  Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data.  Minor    \u2718         32  4120  Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause.  Critical      \u2718       33  4130  Always close locally opened cursors.  Major   \u2718    \u2718       34  4140  Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute.  Major      \u2718       35  4210  Try to use CASE rather than an IF statement with multiple ELSIF paths.  Major    \u2718      \u2718    36  4220  Try to use CASE rather than DECODE.  Minor    \u2718  \u2718        37  4230  Always use COALESCE instead of NVL, if parameter 2 of the NVL function is a function call or a SELECT statement.  Critical   \u2718    \u2718       38  4240  Always use CASE instead of NVL2 if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement.  Critical   \u2718    \u2718       39  4310  Never use GOTO statements in your code.  Major    \u2718      \u2718    40  4320  Always label your loops.  Minor    \u2718         41  4330  Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations.  Minor    \u2718         42  4340  Always use a NUMERIC FOR loop to process a dense array.  Minor    \u2718         43  4350  Always use 1 as lower and COUNT() as upper bound when looping through a dense array.  Major      \u2718       44  4360  Always use a WHILE loop to process a loose array.  Minor   \u2718          45  4370  Avoid using EXIT to stop loop processing unless you are in a basic loop.  Major    \u2718         46  4375  Always use EXIT WHEN instead of an IF statement to exit from a loop.  Minor    \u2718         47  4380  Try to label your EXIT WHEN statements.  Minor    \u2718         48  4385  Never use a cursor for loop to check whether a cursor returns data.  Major   \u2718          49  4390  Avoid use of unreferenced FOR loop indexes.  Major   \u2718          50  4395  Avoid hard-coded upper or lower bound values with FOR loops.  Minor  \u2718   \u2718         n/a  5010  Try to use a error/logging framework for your application.  Critical      \u2718  \u2718   \u2718    51  5020  Never handle unnamed exceptions using the error number.  Critical    \u2718         52  5030  Never assign predefined exception names to user defined exceptions.  Blocker      \u2718    \u2718    53  5040  Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers.  Major      \u2718       54  n/a  Avoid use of EXCEPTION_INIT pragma for a  20nnn error.  Major      \u2718       55  5050  Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded  20nnn error number or hard-coded message.  Major  \u2718   \u2718         56  5060  Avoid unhandled exceptions  Major      \u2718       57  5070  Avoid using Oracle predefined exceptions  Critical      \u2718       58  6010  Always use a character variable to execute dynamic SQL.  Major    \u2718      \u2718    59  6020  Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause.  Minor    \u2718         60  7110  Try to use named notation when calling program units.  Major  \u2718   \u2718         61  7120  Always add the name of the program unit to its end keyword.  Minor    \u2718         62  7130  Always use parameters or pull in definitions rather than referencing external variables in a local program unit.  Major    \u2718   \u2718    \u2718    63  7140  Always ensure that locally defined procedures or functions are referenced.  Major    \u2718   \u2718       64  7150  Try to remove unused parameters.  Minor   \u2718  \u2718         65  7210  Try to keep your packages small. Include only few procedures and functions that are used in the same context.  Minor   \u2718  \u2718         66  7220  Always use forward declaration for private functions and procedures.  Minor  \u2718           67  7230  Avoid declaring global variables public.  Major      \u2718       68  7240  Avoid using an IN OUT parameter as IN or OUT only.  Major   \u2718  \u2718         69  7310  Avoid standalone procedures \u2013 put your procedures in packages.  Minor    \u2718         70  7320  Avoid using RETURN statements in a PROCEDURE.  Major    \u2718      \u2718    71  7410  Avoid standalone functions \u2013 put your functions in packages.  Minor    \u2718         73  7420  Always make the RETURN statement the last statement of your function.  Major    \u2718         72  7430  Try to use no more than one RETURN statement within a function.  Major    \u2718      \u2718    74  7440  Never use OUT parameters to return values from a function.  Major       \u2718      75  7450  Never return a NULL value from a BOOLEAN function.  Major      \u2718    \u2718    n/a  7460  Try to define your packaged/standalone function to be deterministic if appropriate.  Major   \u2718          76  7510  Always prefix ORACLE supplied packages with owner schema name.  Major        \u2718     77  7710  Avoid cascading triggers.  Major    \u2718      \u2718    n/a  7810  Do not use SQL inside PL/SQL to read sequence numbers (or SYSDATE)  Major   \u2718  \u2718         78  8110  Never use SELECT COUNT(*) if you are only interested in the existence of a row.  Major   \u2718          n/a  8120  Never check existence of a row to decide whether to create it or not.  Major   \u2718    \u2718       79  8210  Always use synonyms when accessing objects of another application schema.  Major  \u2718   \u2718         n/a  8310  Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit.  Minor    \u2718   \u2718  \u2718   \u2718    n/a  8410  Always use application locks to ensure a program unit only running once at a given time.  Minor   \u2718    \u2718       n/a  8510  Always use dbms_application_info to track program process transiently  Minor   \u2718    \u2718",
            "title": "A - Mapping new guidelines to prior versions"
        }
    ]
}